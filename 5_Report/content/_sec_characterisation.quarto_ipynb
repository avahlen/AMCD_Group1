{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Characterisation\n",
        "\n",
        "this chap is more about our biquad, and how we made it the way it is now\n",
        "\n",
        "i am failry open to discuss the exact contents of this chapter, as it is the one i am the most unsure about\n",
        "\n",
        "we also need to excatly decide on where this chapter ends, as Finn will continue with chap 5 and the break between the chapters shall be as smooth as possible\n",
        "\n",
        ":::{.callout-warning}\n",
        "decide on the chapter intro when it is clear where the cut is between this chapter and the next\n",
        ":::\n",
        "\n",
        "## Behauvioural Analysis and macro modelling\n",
        "\n",
        "The behauvioural analysis is done through macro modelling the universal biquad filter as a system. The system can be described with transfer functions and modelled with python.\n",
        "\n",
        "### Transfer Functions and frequency response\n",
        "\n",
        ":::{.callout-warning}\n",
        "This whole section needs to be reworked, I am not happy with the reading flow right now! -AvA\n",
        "\n",
        "I am going to shift the theory over to theory and only talk about the implementation...\n",
        ":::\n",
        "\n",
        "The ASLK PRO Manual [@aslkpro2012] provides the transfer functions of the four filter outputs: low pass, high pass, band pass, and band stop. The transfer functions are adaptations of the general second order transfer function as seen in @eq-TFSecondOrder. [@razavi2018]\n",
        "\n",
        "In the following transfer function the input and output voltage are referenced according to @fig-BiquadCircuit. The sections only contain their specific transfer function and frequency response.\n",
        "\n",
        ":::{.callout-warning}\n",
        "please recheck ALL TFs against manual for corecctness\n",
        ":::\n",
        "\n",
        "#### Low pass\n",
        "\n",
        "The output if the low pass filter is marked in the circuit (@fig-BiquadCircuit) as $LPF$ and corresponds to $V_{03}$ in the transfer function @eq-TFLowpass.\n",
        "\n",
        "$$\n",
        "\\frac{V_{03}}{V_i} = \\frac{H_0}{\\left( 1 + \\frac{s}{\\omega_0 Q} + \\frac{s^2}{\\omega_0^2} \\right)}\n",
        "$$ {#eq-TFLowpass}\n",
        "\n",
        "@fig-freqResponseLowpass shows the amplitude and phase response of the low pass filter. The required frequency $f_0 = 1\\,kHz$ and quality factor $Q = 10$ recognizable in the bode plot. As the dc-gain was chosen to be $H_0 = 1$, the low pass filter has a amplitude amplification of 1 in the lower frequencies.\n"
      ],
      "id": "dd769465"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-freqResponseLowpass\n",
        "#| fig-cap: Frequency response of the low pass filter\n",
        "#| code-fold: true\n",
        "\n",
        "# Behavioral Analysis Biquad Filter\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Initial values\n",
        "f0 = 1e3  # Resonance frequency in Hz\n",
        "w0 = 2 * np.pi * f0  # Angular frequency in rad/s\n",
        "Q = 10  # Quality factor\n",
        "H0 = 1  # Play around with this later\n",
        "\n",
        "# Logarithmic frequency axis\n",
        "frequencies = np.logspace(2, 4, 10000)  # Frequency from 10^2 to 10^4 Hz\n",
        "s = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n",
        "\n",
        "############################################\n",
        "# Transfer functions of Active Filters\n",
        "############################################\n",
        "\n",
        "### Numerator\n",
        "# Low Pass Filter\n",
        "b_lp = H0\n",
        "\n",
        "# High Pass Filter\n",
        "b_hp = (H0 * (s**2 / w0**2))\n",
        "\n",
        "# Band Pass Filter\n",
        "b_bp = (-H0 * (s / w0))\n",
        "\n",
        "# Band Stop Filter\n",
        "b_bs = -((1 + (s**2 / (w0**2))) * H0)\n",
        "\n",
        "# Denominator -> for all filters the same\n",
        "a0 = 1\n",
        "a1 = (s / (w0 * Q))\n",
        "a2 = (s**2 / (w0**2))\n",
        "\n",
        "den = a0 + a1 + a2\n",
        "\n",
        "############################################\n",
        "# Calculation of the transfer functions H(s)\n",
        "############################################\n",
        "Hs_lp = b_lp / den\n",
        "Hs_hp = b_hp / den\n",
        "Hs_bp = b_bp / den\n",
        "Hs_bs = b_bs / den\n",
        "\n",
        "# Bode Diagram\n",
        "fig, axs = plt.subplots(2)\n",
        "#fig.suptitle(\"frequency response of biquad filter\")\n",
        "\n",
        "# Low Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp)), label='low pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp)) * (180 / np.pi), label='low pass')\n",
        "'''\n",
        "# High Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='high pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_hp)) * (180 / np.pi), label='high pass')\n",
        "\n",
        "# Band Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='band pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_bp)) * (180 / np.pi), label='band pass')\n",
        "\n",
        "# Band Stop Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='band stop')\n",
        "axs[1].semilogx(frequencies, (np.angle(Hs_bs)) * (180 / np.pi), label='band stop')\n",
        "'''\n",
        "#axs[0].title(\"amplitude response\")\n",
        "axs[0].set_xlabel(\"frequency/Hz\")\n",
        "axs[0].set_ylabel(\"amplitude/dB\")\n",
        "axs[0].set_ylim(-50, 25)\n",
        "axs[0].grid(True, which=\"both\", ls=\"--\")\n",
        "#axs[0].legend(loc=1)\n",
        "\n",
        "#axs[1].title(\"phase response\")\n",
        "axs[1].set_xlabel(\"frequency/Hz\")\n",
        "axs[1].set_ylabel(\"phase/deg\")\n",
        "axs[1].grid(True, which=\"both\", ls=\"--\")\n",
        "#axs[1].legend()\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "fig-freqResponseLowpass",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "With knowing the dc gain $H_0 = 1$ and quality factot $Q = 10$, the amplitude of the peak can be calculated as seen in @eq-calculatePeak. Expression the value in dB, gives peak amplitude of $A_{peak,dB} = 20.002\\,dB$ which corresponds to the peak value seen in @fig-freqResponseLowpass.\n",
        "\n",
        "#### High pass\n",
        "\n",
        "The output if the high pass filter is marked in the circuit (@fig-BiquadCircuit) as $HPF$ and corresponds to $V_{01}$ in the transfer function @eq-TFHighpass.\n",
        "\n",
        "$$\n",
        "\\frac{V_{01}}{V_i} = \\frac{\\left( H_0 \\cdot \\frac{s^2}{\\omega_0^2} \\right)}{\\left( 1 + \\frac{s}{\\omega_0 Q} + \\frac{s^2}{\\omega_0^2} \\right)} \n",
        "$$ {#eq-TFHighpass}\n",
        "\n",
        "@fig-freqResponseLowpass shows the amplitude and phase response of the high pass filter. The required frequency $f_0 = 1\\,kHz$ and quality factor $Q = 10$ recognizable in the bode plot. As the dc-gain was chosen to be $H_0 = 1$, the low pass filter has a amplitude amplification of 1 in the higher frequencies.\n"
      ],
      "id": "0de3d01c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-freqResponseHighpass\n",
        "#| fig-cap: Frequency response of the high pass filter\n",
        "#| code-fold: true\n",
        "\n",
        "# Behavioral Analysis Biquad Filter\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Initial values\n",
        "f0 = 1e3  # Resonance frequency in Hz\n",
        "w0 = 2 * np.pi * f0  # Angular frequency in rad/s\n",
        "Q = 10  # Quality factor\n",
        "H0 = 1  # Play around with this later\n",
        "\n",
        "# Logarithmic frequency axis\n",
        "frequencies = np.logspace(2, 4, 10000)  # Frequency from 10^2 to 10^4 Hz\n",
        "s = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n",
        "\n",
        "############################################\n",
        "# Transfer functions of Active Filters\n",
        "############################################\n",
        "\n",
        "### Numerator\n",
        "# Low Pass Filter\n",
        "b_lp = H0\n",
        "\n",
        "# High Pass Filter\n",
        "b_hp = (H0 * (s**2 / w0**2))\n",
        "\n",
        "# Band Pass Filter\n",
        "b_bp = (-H0 * (s / w0))\n",
        "\n",
        "# Band Stop Filter\n",
        "b_bs = -((1 + (s**2 / (w0**2))) * H0)\n",
        "\n",
        "# Denominator -> for all filters the same\n",
        "a0 = 1\n",
        "a1 = (s / (w0 * Q))\n",
        "a2 = (s**2 / (w0**2))\n",
        "\n",
        "den = a0 + a1 + a2\n",
        "\n",
        "############################################\n",
        "# Calculation of the transfer functions H(s)\n",
        "############################################\n",
        "Hs_lp = b_lp / den\n",
        "Hs_hp = b_hp / den\n",
        "Hs_bp = b_bp / den\n",
        "Hs_bs = b_bs / den\n",
        "\n",
        "# Bode Diagram\n",
        "fig, axs = plt.subplots(2)\n",
        "#fig.suptitle(\"frequency response of biquad filter\")\n",
        "\n",
        "# Low Pass Filter\n",
        "#axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp)), label='low pass')\n",
        "#axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp)) * (180 / np.pi), label='low pass')\n",
        "\n",
        "# High Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='high pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_hp)) * (180 / np.pi), label='high pass')\n",
        "'''\n",
        "# Band Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='band pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_bp)) * (180 / np.pi), label='band pass')\n",
        "\n",
        "# Band Stop Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='band stop')\n",
        "axs[1].semilogx(frequencies, (np.angle(Hs_bs)) * (180 / np.pi), label='band stop')\n",
        "'''\n",
        "#axs[0].title(\"amplitude response\")\n",
        "axs[0].set_xlabel(\"frequency/Hz\")\n",
        "axs[0].set_ylabel(\"amplitude/dB\")\n",
        "axs[0].set_ylim(-50, 25)\n",
        "axs[0].grid(True, which=\"both\", ls=\"--\")\n",
        "#axs[0].legend(loc=1)\n",
        "\n",
        "#axs[1].title(\"phase response\")\n",
        "axs[1].set_xlabel(\"frequency/Hz\")\n",
        "axs[1].set_ylabel(\"phase/deg\")\n",
        "axs[1].grid(True, which=\"both\", ls=\"--\")\n",
        "#axs[1].legend()\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "fig-freqResponseHighpass",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Band pass\n",
        "\n",
        "The output for the band pass filter is marked as $BPF$ in @fig-BiquadCircuit. This denotes the point that is referenced in @eg-TFBandpass as $V_{02}$.\n",
        "\n",
        "$$\n",
        "\\frac{V_{02}}{V_i} = \\frac{\\left( - H_0 \\cdot \\frac{s}{\\omega_0} \\right)}{\\left( 1 + \\frac{s}{\\omega_0 Q} + \\frac{s^2}{\\omega_0^2} \\right)}\n",
        "$$ {#eq-TFBandpass}\n",
        "\n",
        "The band pass shown in @fig-freqResponseBandpass has its center frequency at $1\\,kHz$ as set in the requirements. Similarly to the low pass filter in @fig-freqResponseLowpass and the high pass filter in @fig-freqResponseHighpass the amplitude response peaks at this frequency, with its peak influenced by the quality factor.\n"
      ],
      "id": "6f75ed25"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-freqResponseBandpass\n",
        "#| fig-cap: Frequency response of the band pass filter\n",
        "#| code-fold: true\n",
        "\n",
        "# Behavioral Analysis Biquad Filter\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Initial values\n",
        "f0 = 1e3  # Resonance frequency in Hz\n",
        "w0 = 2 * np.pi * f0  # Angular frequency in rad/s\n",
        "Q = 10  # Quality factor\n",
        "H0 = 1  # Play around with this later\n",
        "\n",
        "# Logarithmic frequency axis\n",
        "frequencies = np.logspace(2, 4, 10000)  # Frequency from 10^2 to 10^4 Hz\n",
        "s = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n",
        "\n",
        "############################################\n",
        "# Transfer functions of Active Filters\n",
        "############################################\n",
        "\n",
        "### Numerator\n",
        "# Low Pass Filter\n",
        "b_lp = H0\n",
        "\n",
        "# High Pass Filter\n",
        "b_hp = (H0 * (s**2 / w0**2))\n",
        "\n",
        "# Band Pass Filter\n",
        "b_bp = (-H0 * (s / w0))\n",
        "\n",
        "# Band Stop Filter\n",
        "b_bs = -((1 + (s**2 / (w0**2))) * H0)\n",
        "\n",
        "# Denominator -> for all filters the same\n",
        "a0 = 1\n",
        "a1 = (s / (w0 * Q))\n",
        "a2 = (s**2 / (w0**2))\n",
        "\n",
        "den = a0 + a1 + a2\n",
        "\n",
        "############################################\n",
        "# Calculation of the transfer functions H(s)\n",
        "############################################\n",
        "Hs_lp = b_lp / den\n",
        "Hs_hp = b_hp / den\n",
        "Hs_bp = b_bp / den\n",
        "Hs_bs = b_bs / den\n",
        "\n",
        "# Bode Diagram\n",
        "fig, axs = plt.subplots(2)\n",
        "#fig.suptitle(\"frequency response of biquad filter\")\n",
        "'''\n",
        "# Low Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp)), label='low pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp)) * (180 / np.pi), label='low pass')\n",
        "\n",
        "# High Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='high pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_hp)) * (180 / np.pi), label='high pass')\n",
        "'''\n",
        "# Band Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='band pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_bp)) * (180 / np.pi), label='band pass')\n",
        "\n",
        "# Band Stop Filter\n",
        "#axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='band stop')\n",
        "#axs[1].semilogx(frequencies, (np.angle(Hs_bs)) * (180 / np.pi), label='band stop')\n",
        "\n",
        "#axs[0].title(\"amplitude response\")\n",
        "axs[0].set_xlabel(\"frequency/Hz\")\n",
        "axs[0].set_ylabel(\"amplitude/dB\")\n",
        "axs[0].set_ylim(-50, 25)\n",
        "axs[0].grid(True, which=\"both\", ls=\"--\")\n",
        "#axs[0].legend(loc=1)\n",
        "\n",
        "#axs[1].title(\"phase response\")\n",
        "axs[1].set_xlabel(\"frequency/Hz\")\n",
        "axs[1].set_ylabel(\"phase/deg\")\n",
        "axs[1].grid(True, which=\"both\", ls=\"--\")\n",
        "#axs[1].legend()\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "fig-freqResponseBandpass",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Band stop\n",
        "\n",
        "The output for the band stop filter is marked in @fig-BiquadCircuit as $BSF$ and in the transfer function as $V_{04}$.\n",
        "\n",
        "$$\n",
        "\\frac{V_{04}}{V_i} = \\frac{\\left( 1 + \\frac{s^2}{\\omega_0^2} \\right) \\cdot H_0}{\\left( 1 + \\frac{s}{\\omega_0 Q} + \\frac{s^2}{\\omega_0^2} \\right)}\n",
        "$$ {#eq-TFBandstopFalse}\n",
        "\n",
        "[@renner2025] argues that @eq-TFBandstopFalse from the ASLK PRO Manual [@aslkpro2012] is incorrect, as using that equation produces inconsistent results. Using the negated form of @eq-TFBandstopFalse as seen in @eq-TFBandstopCorrect seems to produce the correct output. Therefore @eq-TFBandstopCorrect will be used for further analysis.\n",
        "\n",
        "$$\n",
        "\\frac{V_{04}}{V_i} = - \\frac{\\left( 1 + \\frac{s^2}{\\omega_0^2} \\right) \\cdot H_0}{\\left( 1 + \\frac{s}{\\omega_0 Q} + \\frac{s^2}{\\omega_0^2} \\right)}\n",
        "$$ {#eq-TFBandstopCorrect}\n",
        "\n",
        "@fig-freqResponseBandstop shows the frequency response of the band stop, with its center frequency at $1\\,kHz$.\n"
      ],
      "id": "50b328d2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-freqResponseBandstop\n",
        "#| fig-cap: Frequency response of the band stop filter\n",
        "#| code-fold: true\n",
        "\n",
        "# Behavioral Analysis Biquad Filter\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Initial values\n",
        "f0 = 1e3  # Resonance frequency in Hz\n",
        "w0 = 2 * np.pi * f0  # Angular frequency in rad/s\n",
        "Q = 10  # Quality factor\n",
        "H0 = 1  # Play around with this later\n",
        "\n",
        "# Logarithmic frequency axis\n",
        "frequencies = np.logspace(2, 4, 10000)  # Frequency from 10^2 to 10^4 Hz\n",
        "s = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n",
        "\n",
        "############################################\n",
        "# Transfer functions of Active Filters\n",
        "############################################\n",
        "\n",
        "### Numerator\n",
        "# Low Pass Filter\n",
        "b_lp = H0\n",
        "\n",
        "# High Pass Filter\n",
        "b_hp = (H0 * (s**2 / w0**2))\n",
        "\n",
        "# Band Pass Filter\n",
        "b_bp = (-H0 * (s / w0))\n",
        "\n",
        "# Band Stop Filter\n",
        "b_bs = -((1 + (s**2 / (w0**2))) * H0)\n",
        "\n",
        "# Denominator -> for all filters the same\n",
        "a0 = 1\n",
        "a1 = (s / (w0 * Q))\n",
        "a2 = (s**2 / (w0**2))\n",
        "\n",
        "den = a0 + a1 + a2\n",
        "\n",
        "############################################\n",
        "# Calculation of the transfer functions H(s)\n",
        "############################################\n",
        "Hs_lp = b_lp / den\n",
        "Hs_hp = b_hp / den\n",
        "Hs_bp = b_bp / den\n",
        "Hs_bs = b_bs / den\n",
        "\n",
        "# Bode Diagram\n",
        "fig, axs = plt.subplots(2)\n",
        "#fig.suptitle(\"frequency response of biquad filter\")\n",
        "'''\n",
        "# Low Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp)), label='low pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp)) * (180 / np.pi), label='low pass')\n",
        "\n",
        "# High Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='high pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_hp)) * (180 / np.pi), label='high pass')\n",
        "\n",
        "# Band Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='band pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_bp)) * (180 / np.pi), label='band pass')\n",
        "'''\n",
        "# Band Stop Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='band stop')\n",
        "axs[1].semilogx(frequencies, (np.angle(Hs_bs)) * (180 / np.pi), label='band stop')\n",
        "\n",
        "#axs[0].title(\"amplitude response\")\n",
        "axs[0].set_xlabel(\"frequency/Hz\")\n",
        "axs[0].set_ylabel(\"amplitude/dB\")\n",
        "axs[0].set_ylim(-50, 25)\n",
        "axs[0].grid(True, which=\"both\", ls=\"--\")\n",
        "#axs[0].legend(loc=1)\n",
        "\n",
        "#axs[1].title(\"phase response\")\n",
        "axs[1].set_xlabel(\"frequency/Hz\")\n",
        "axs[1].set_ylabel(\"phase/deg\")\n",
        "axs[1].grid(True, which=\"both\", ls=\"--\")\n",
        "#axs[1].legend()\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "fig-freqResponseBandstop",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Comparison\n",
        "\n",
        "some text...\n"
      ],
      "id": "8a75fa73"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-freqResponseFilter\n",
        "#| fig-cap: Behauvioural analysis of biquad filter\n",
        "#| code-fold: true\n",
        "\n",
        "# Behavioral Analysis Biquad Filter\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Initial values\n",
        "f0 = 1e3  # Resonance frequency in Hz\n",
        "w0 = 2 * np.pi * f0  # Angular frequency in rad/s\n",
        "Q = 10  # Quality factor\n",
        "H0 = 1  # Play around with this later\n",
        "\n",
        "# Logarithmic frequency axis\n",
        "frequencies = np.logspace(2, 4, 10000)  # Frequency from 10^2 to 10^4 Hz\n",
        "s = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n",
        "\n",
        "############################################\n",
        "# Transfer functions of Active Filters\n",
        "############################################\n",
        "\n",
        "### Numerator\n",
        "# Low Pass Filter\n",
        "b_lp = H0\n",
        "\n",
        "# High Pass Filter\n",
        "b_hp = (H0 * (s**2 / w0**2))\n",
        "\n",
        "# Band Pass Filter\n",
        "b_bp = (-H0 * (s / w0))\n",
        "\n",
        "# Band Stop Filter\n",
        "b_bs = -((1 + (s**2 / (w0**2))) * H0)\n",
        "\n",
        "# Denominator -> for all filters the same\n",
        "a0 = 1\n",
        "a1 = (s / (w0 * Q))\n",
        "a2 = (s**2 / (w0**2))\n",
        "\n",
        "den = a0 + a1 + a2\n",
        "\n",
        "############################################\n",
        "# Calculation of the transfer functions H(s)\n",
        "############################################\n",
        "Hs_lp = b_lp / den\n",
        "Hs_hp = b_hp / den\n",
        "Hs_bp = b_bp / den\n",
        "Hs_bs = b_bs / den\n",
        "\n",
        "# Bode Diagram\n",
        "fig, axs = plt.subplots(2)\n",
        "#fig.suptitle(\"frequency response of biquad filter\")\n",
        "\n",
        "# Low Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp)), label='low pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp)) * (180 / np.pi), label='low pass')\n",
        "\n",
        "# High Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='high pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_hp)) * (180 / np.pi), label='high pass')\n",
        "\n",
        "# Band Pass Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='band pass')\n",
        "axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_bp)) * (180 / np.pi), label='band pass')\n",
        "\n",
        "# Band Stop Filter\n",
        "axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='band stop')\n",
        "axs[1].semilogx(frequencies, (np.angle(Hs_bs)) * (180 / np.pi), label='band stop')\n",
        "\n",
        "#axs[0].title(\"amplitude response\")\n",
        "axs[0].set_xlabel(\"frequency/Hz\")\n",
        "axs[0].set_ylabel(\"amplitude/dB\")\n",
        "axs[0].set_ylim(-50, 25)\n",
        "axs[0].grid(True, which=\"both\", ls=\"--\")\n",
        "axs[0].legend(loc=1)\n",
        "\n",
        "#axs[1].title(\"phase response\")\n",
        "axs[1].set_xlabel(\"frequency/Hz\")\n",
        "axs[1].set_ylabel(\"phase/deg\")\n",
        "axs[1].grid(True, which=\"both\", ls=\"--\")\n",
        "axs[1].legend()\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "fig-freqResponseFilter",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Stability\n",
        "\n",
        "The stability of the biquad is checked at different hierarchical levels. The first analysis considers the system from a theorectical standpoint with transfer functions, and checks if conceptual design of the biquad filter is stable. On a component level the stability of the integrators and adders is analyzed, to verify that the chosen values for resistors and capcitors do not induce oscillations through the feedback loop. \n",
        "\n",
        "(At last, the general stability of the OTA circuit itself needs to be checked, so that) <- lets see what we can find for this...\n",
        "\n",
        "#### System stability\n",
        "A system is stable if its impulse response is absolutley integrateable. In case of a given transfer function, this can also be checked by calculating the poles of the transfer function. If all the poles lay in the left half of the s-plane, the system is considered stable. There is a special case where single poles can lay on the $j\\omega$-axis, on their own or in combination with poles in the left half of the s-plane. Systems which fall under that, are called marginally stable. [@fliege1991]\n",
        "\n",
        "#### Pole-zero plot\n"
      ],
      "id": "76d0c04d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-poleZeroStability\n",
        "#| fig-cap: Pole-zero plot for all transfer functions\n",
        "#| code-fold: true\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from scipy.signal import tf2zpk\n",
        "\n",
        "# Given values\n",
        "f = 1e3\n",
        "w = 2 * np.pi * f\n",
        "R = 1e3\n",
        "C = 1 / (w * R)\n",
        "Q = 10\n",
        "H0 = 1\n",
        "\n",
        "# Calculate w0\n",
        "w0 = 1 / (R * C)\n",
        "\n",
        "# Transfer function coefficients\n",
        "a2 = 1 / w0**2\n",
        "a1 = 1 / (w0 * Q)\n",
        "a0 = 1\n",
        "\n",
        "# Define transfer functions manually as (numerator, denominator) pairs\n",
        "systems = {\n",
        "    'Low pass filter': ([H0], [a2, a1, a0]),\n",
        "    'High pass filter': ([H0 / w0**2, 0, 0], [a2, a1, a0]),\n",
        "    'Band pass filter': ([-H0 / w0, 0], [a2, a1, a0]),\n",
        "    'Band stop filter': ([H0 / w0**2, 0, H0], [a2, a1, a0])\n",
        "}\n",
        "\n",
        "# Function to plot pole-zero map\n",
        "def plot_pzmap(num, den, title, subplot_pos):\n",
        "    zeros, poles, _ = tf2zpk(num, den)\n",
        "    plt.subplot(2, 2, subplot_pos)\n",
        "    plt.plot(np.real(zeros), np.imag(zeros), 'go', label='Zeros')\n",
        "    plt.plot(np.real(poles), np.imag(poles), 'rx', label='Poles')\n",
        "    plt.axhline(0, color='gray', lw=0.5)\n",
        "    plt.axvline(0, color='gray', lw=0.5)\n",
        "    plt.title(title)\n",
        "    plt.xlim([-1500, 1500])\n",
        "    plt.ylim([-10000, 10000])\n",
        "    plt.grid(True)\n",
        "    plt.legend(loc='upper right')\n",
        "\n",
        "# Plot all systems\n",
        "plt.figure(figsize=(12, 10))\n",
        "for i, (title, (num, den)) in enumerate(systems.items(), 1):\n",
        "    plot_pzmap(num, den, title, i)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n"
      ],
      "id": "fig-poleZeroStability",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "@fig-poleZeroStability shows the pole-zero plots of all four filters, low pass, high pass, band pass and band stop. In all four plots the poles are located in the left half of the s-plane and the system can therefore theoretically be classified as stable. [@razavi2018] confirms this, as the article explains that with $Q \\rightarrow \\infty$ the poles of the system approach the $j\\omega$ axis and the system becomes unstable.\n",
        "\n",
        "This analysis onbly considers the system as a mathematical model and as a whole. Further considerations regarding the stability of the components, integrators and adders, and the stability of the operational amplifiers themselves, have to be done.\n",
        "\n",
        "#### Component stability\n",
        "\n",
        "Circuits with opamps often have feedback loops, meaning that the output of the operational amplifier is somehow connected to the inverted input of the opamp. These feedback loops become problematic when the feedback signal is in phase with the input signal, as positive feedback is created and the circuit is working as an oscillator. [@reisch2007]\n",
        "\n",
        "The stability of the non-inverting amplifier can be verified by calculating the phase reserve $\\alpha$ of the circuit. If $f_k$ is the frequency where the feedback gain is equal to 1 and $\\varphi_k$ is the corresponding phase to that frequency, then \n",
        "the phase reserve is calculated by:\n",
        "\n",
        "$$\n",
        "\\alpha = 180°\n",
        "$$\n",
        "\n",
        "For circuits to be considered stable, the phase reserve has to be positive. To reduce overshoots during the transient response, it is customary to have a phase reserve of $\\alpha > 45°$. [@reisch2007]\n",
        "\n",
        ":::{.callout-warning}\n",
        "insert figure from reisch page 244\n",
        ":::\n",
        "\n",
        "![Example of a transcient response of a circuit with a phase reserve of $\\alpha = 5.7°$ [@reisch2007]](/images/sec_characterisation/reisch_stability_example_trans.png){#fig-reischExampleStabilityTransient}\n",
        "\n",
        "Figure (reisch) shows the transient response of a circuit with a phase reserve of $\\alpha = 5.7°. The overshoots are clearly visible and number of the overshoots per puls are larger then the customary \"one over, one under\"-rule. As the phase reserve is positive, the figure shows that even though the transient response is not ideal, the oscillations are attenuated and the circuit is can be considered as stable.\n",
        "\n",
        "In practical application, the phase reserve can be graphically determined with the help of bode diagrams. The bode diagram of the circuit with an open feedback loop is simulated, so that the frequency $f_k$ can be read out. This is the frequnecy where the feedback gain is 1 or 0 dB. The corresponding frequency to that, is the phase of the feedback gain $\\varphi_k$, the difference between $-180°$ and $\\varphi_k$ is the phase reserve $\\alpha$. [@reisch2007]\n",
        "\n",
        ":::{.callout-warning}\n",
        "insert circuit where the stability analsis was done from, like in ltspice\n",
        ":::\n",
        "\n",
        ":::{.callout-warning}\n",
        "insert bode diagram figures (both: integrator and adder)\n",
        ":::\n",
        "\n",
        "In the following figures (ref) and (ref) this method was used to determine the stability over the phase reserve.\n",
        "(add here part about whether they are stable...)\n",
        "\n",
        "#### OTA stability\n",
        "\n",
        "i have not found anything in pretl script, but i clearly remember mr. meiners talking about this...\n",
        "\n",
        "### Ideal Opamp\n",
        "\n",
        "kinda forgot where I wanted to go with this one... ehhh maybe it will come back\n",
        "\n",
        "uhhh i think it was about the ideal circuit and spice analysis etc\n",
        "\n",
        "To check the behauviour of the implemented circuit against the modelled behauviour of the transfer function, the universal biquad was built as an ideal circuit with voltage-regulated current sources instead of OTAs.\n",
        "\n",
        "## Implementation (or Real Circuit)\n",
        "\n",
        "this is about the transition from the ideal circuit to real circuit\n",
        "\n",
        "### used opamp representation\n",
        "\n",
        "like with opamp did we use specifically (5 ota i think), why, what are special about that\n",
        "\n",
        "### Sizing\n",
        "\n",
        "with the script from pretl, if i remember correctly"
      ],
      "id": "843a53cc"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/atakan/quarto-env/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}