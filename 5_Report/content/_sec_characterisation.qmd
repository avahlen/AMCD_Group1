# Characterisation

this chap is more about our biquad, and how we made it the way it is now

i am failry open to discuss the exact contents of this chapter, as it is the one i am the most unsure about

we also need to excatly decide on where this chapter ends, as Finn will continue with chap 5 and the break between the chapters shall be as smooth as possible

## Behauvioural Analysis and macro modelling

The behauvioural analysis is done through macro modelling the universal biquad filter as a system. The system can be described with transfer functions and modelled with python.

### Transfer Functions and frequency response

the python plots based on TF from red pitaya manual

The ASLK PRO Manual [@aslkpro2012] provides the transfer functions of the four filter outputs: low pass, high pass, band pass, and band stop. The transfer functions are adaptations of the general second order transfer function [@razavi2018]:

$$
H(s) = \frac{a_1 \cdot s^2 + b_1 \cdot s + c_1}{a_2 \cdot s^2 + b_2 \cdot s + c_2}
$$

The coeffcients can be choosen so, that different responses, like low pass, high pass, band pass, and band stop are achieved.

In filter design a variant of this generalized transfer function is often choosen to easier describe the system by quality factor and angular frequency [@razavi2018].

$$
H(s) = \frac{\omega_n^2}{s^2 + \frac{\omega_n}{Q} s + \omega_n^2}
$$

In the following transfer function the input and output voltage are referenced according the figure ???. The sections only contain their specific transfer function and frequency response. The python script used to obtain these plots is linked below.

---
title: "python script for plotting frequency responses"
format:
  html:
    code-fold: true
    code-block-border-left: true
    code-line-numbers: true
jupyter: python3
---

```{python}

#| label: fig-freqResponseFilter
#| fig-cap: "Behauvioural analysis of biquad filter"

# Behavioral Analysis Biquad Filter

import numpy as np
import matplotlib.pyplot as plt

# Initial values
f0 = 1e3  # Resonance frequency in Hz
w0 = 2 * np.pi * f0  # Angular frequency in rad/s
Q = 10  # Quality factor
H0 = 1  # Play around with this later

# Logarithmic frequency axis
frequencies = np.logspace(2, 4, 10000)  # Frequency from 10^2 to 10^4 Hz
s = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jÏ‰

############################################
# Transfer functions of Active Filters
############################################

### Numerator
# Low Pass Filter
b_lp = H0

# High Pass Filter
b_hp = (H0 * (s**2 / w0**2))

# Band Pass Filter
b_bp = (-H0 * (s / w0))

# Band Stop Filter
b_bs = -((1 + (s**2 / (w0**2))) * H0)

# Denominator -> for all filters the same
a0 = 1
a1 = (s / (w0 * Q))
a2 = (s**2 / (w0**2))

den = a0 + a1 + a2

############################################
# Calculation of the transfer functions H(s)
############################################
Hs_lp = b_lp / den
Hs_hp = b_hp / den
Hs_bp = b_bp / den
Hs_bs = b_bs / den

# Bode Diagram
fig, axs = plt.subplots(2)
fig.suptitle("Frequency response of biquad filter")

# Low Pass Filter
axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp)), label='Low Pass')
axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp)) * (180 / np.pi), label='Low Pass')

# High Pass Filter
axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='High Pass')
axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_hp)) * (180 / np.pi), label='High Pass')

# Band Pass Filter
axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='Band Pass')
axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_bp)) * (180 / np.pi), label='Band Pass')

# Band Stop Filter
axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='Band Stop')
axs[1].semilogx(frequencies, (np.angle(Hs_bs)) * (180 / np.pi), label='Band Stop')

axs[0].set_xlabel("Frequencies in Hz")
axs[0].set_ylabel("Amplitude in dB")
axs[0].set_ylim(-50, 25)
axs[0].grid()
axs[0].legend(loc=1)

axs[1].set_xlabel("Frequencies in Hz")
axs[1].set_ylabel("Phase in radians")

axs[1].grid()
axs[1].legend()

plt.tight_layout()
plt.show()
```

:::{.callout-warning}
insert ref to universal biquad circuit
:::

:::{.callout-warning}
please recheck ALL TFs against manaul for corecctness
:::

#### Low pass

$$
\frac{V_{03}}{V_i} = \frac{H_0}{\left( 1 + \frac{s}{\omega_0 Q} + \frac{s^2}{\omega_0^2} \right)}
$$ {#eq-TFLowpass}

#### High pass

$$
\frac{V_{01}}{V_i} = \frac{\left( H_0 \cdot \frac{s^2}{\omega_0^2} \right)}{\left( 1 + \frac{s}{\omega_0 Q} + \frac{s^2}{\omega_0^2} \right)} 
$$ {#eq-TFHighpass}

#### Band pass

$$
\frac{V_{02}}{V_i} = \frac{\left( - H_0 \cdot \frac{s}{\omega_0} \right)}{\left( 1 + \frac{s}{\omega_0 Q} + \frac{s^2}{\omega_0^2} \right)}
$$ {#eq-TFBandpass}

#### Band stop

$$
\frac{V_{04}}{V_i} = \frac{\left( 1 + \frac{s^2}{\omega_0^2} \right) \cdot H_0}{\left( 1 + \frac{s}{\omega_0 Q} + \frac{s^2}{\omega_0^2} \right)}
$$ {#eq-TFBandstopFalse}

[@renner2025] argues that @eq-TFBandstopFalse from the ASLK PRO Manual [@aslkpro2012] is incorrect, as using that equation produces inconsistent results. Using the negated form of @eq-TFBandstopFalse as seen in @eq-TFBandstopCorrect seems to produce the correct output. Therefore @eq-TFBandstopCorrect will be used for further analysis.

$$
\frac{V_{04}}{V_i} = - \frac{\left( 1 + \frac{s^2}{\omega_0^2} \right) \cdot H_0}{\left( 1 + \frac{s}{\omega_0 Q} + \frac{s^2}{\omega_0^2} \right)}
$$ {#eq-TFBandstopCorrect}

### Ideal Opamp

kinda forgot where I wanted to go with this one... ehhh maybe it will come back

uhhh i think it was about the ideal circuit and spice analysis etc

## Implementation (or Real Circuit)

this is about the transition from the ideal circuit to real circuit

### used opamp representation

like with opamp did we use specifically (5 ota i think), why, what are special about that

### Sizing

with the script from pretl, if i remember correctly
