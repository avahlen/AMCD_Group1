[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IC Design of a Universal Biquad Filter",
    "section": "",
    "text": "TOC (only temporary)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>IC Design of a Universal Biquad Filter</span>"
    ]
  },
  {
    "objectID": "index.html#gliederung-vorschlag-atakan",
    "href": "index.html#gliederung-vorschlag-atakan",
    "title": "IC Design of a Universal Biquad Filter",
    "section": "0.1 Gliederung Vorschlag (Atakan)",
    "text": "0.1 Gliederung Vorschlag (Atakan)\n\nAbstract\nIntroduction\nTheoretical background 3.1 OTA 3.2 Miller / 2order /biquard 3.3 system overview 3.4 methods\nCharactaristic 4.1 req 4.2 python 4.5 LTspice\nIC design 5.1 ideal 5.2 gm/id 5.3 real\nKlayout\nDiscussion\nConclusion",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>IC Design of a Universal Biquad Filter</span>"
    ]
  },
  {
    "objectID": "index.html#onno",
    "href": "index.html#onno",
    "title": "IC Design of a Universal Biquad Filter",
    "section": "0.2 ONNO",
    "text": "0.2 ONNO\n\nAbstract\nIntruduction\nTheoretical View 3.1 (OP) 3.2 OTA 3.3 Biasing 3.4 Biquad\nTop_Level (ASLK) 4.1 Simulation 4.1.1 Python 4.1.2 PSpice 4.1.3 Xschem\nBauteilebene 5.1 Intruduction (Pretl) 5.2 Parameters 5.2 Xschem 5.3 Miller\nIC-Design K_Layout\nDiscussion",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>IC Design of a Universal Biquad Filter</span>"
    ]
  },
  {
    "objectID": "index.html#toc-suggestion-main",
    "href": "index.html#toc-suggestion-main",
    "title": "IC Design of a Universal Biquad Filter",
    "section": "0.3 TOC suggestion (Main)",
    "text": "0.3 TOC suggestion (Main)\n\nAbstract (max. 0,5 page)\nIntroduction (1 page)\n\n2.1 Motivation 2.2 Scope 2.3 Constraints (Meiners Kram)\n\nTheoretical Background 3.1 Opamp 3.1.1 Current Mirror 3.1.2 Diff Stage 3.1.2 Variants (like Miller maybe?) 3.1.3 Small signal representation 3.1.4 Stability 3.1.5 Sizing? 3.2 Biquad 3.2.1 Characteristics 3.2.2 Stability\nCharacterisation 4.1 Behavioural analysis 4.1.1 Python 4.1.2 Ideal Opamp? 4.2 Implementation (real circuit) 4.2.1 Used opamp representation 4.2.2 Sizing\nDesign 5.1 methods 5.1.1 Xschem 5.1.2 ngspice 5.1.3 KLayout 5.2 Process siehe finn\nDiscussion 6.1 Stability Analysis 6.2 Comparison 6.2.1 Python 6.2.2 Ideal 6.2.3 Real 6.3 is filter good?\nConclusion and outlook",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>IC Design of a Universal Biquad Filter</span>"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html",
    "href": "content/_sec_introduction.html",
    "title": "TOC (only temporary)",
    "section": "",
    "text": "New Final Final (no rEALLY) structure of doc\nLegend:\n0 Abstract (missing)\n1 Introduction\n1.1 Motivation (review)\n1.2 Scope of the Project (review)\n1.3 Specifications (review)\n1.4 Open Source (editing)\n2 Theorectic Background 2.1 Biquad Filter 2.1.2 Universal Biquad Filter (editing) 2.2 …Übergang von Biquad zu Mosfet über opamp/OTA (writing) 2.3 MOSFET (writing)\n3 Characteristics (writing)\n4 Implementation (writing)\n5 Finns Layout (writing)\n6 Diskussion (missing)\n7 Conclusion and Outlook (missing)",
    "crumbs": [
      "TOC (only temporary)"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html#new-final-final-no-really-structure-of-doc",
    "href": "content/_sec_introduction.html#new-final-final-no-really-structure-of-doc",
    "title": "TOC (only temporary)",
    "section": "",
    "text": "finished (no more work needs to be done)\nreview (peer review ongoing)\nediting (generally done, small todos like formatting, missing figure, links, etc)\nwriting (currently under construction by fixed person responsible)\nplanning (no text yet, but fixed person)\nmissing (NOTHING, complete emptiness)",
    "crumbs": [
      "TOC (only temporary)"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html#to-dos",
    "href": "content/_sec_introduction.html#to-dos",
    "title": "TOC (only temporary)",
    "section": "To Dos",
    "text": "To Dos",
    "crumbs": [
      "TOC (only temporary)"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html#toc-suggestion-main",
    "href": "content/_sec_introduction.html#toc-suggestion-main",
    "title": "TOC (only temporary)",
    "section": "TOC suggestion (Main)",
    "text": "TOC suggestion (Main)\n1 Abstract (max. 0,5 page)\n2 Introduction (1 page)\n2.1 Motivation\n2.2 Scope\n2.3 Constraints (Meiners Kram)\n3 Theoretical Background\n3.1 Opamp\n3.1.1 Current Mirror\n3.1.2 Diff Stage\n3.1.2 Variants (like Miller maybe?) 3.1.3 Small signal representation 3.1.4 Stability 3.1.5 Sizing? 3.2 Biquad 3.2.1 Characteristics 3.2.2 Stability\n4 Characterisation 4.1 Behavioural analysis 4.1.1 Python 4.1.2 Ideal Opamp? 4.2 Implementation (real circuit) 4.2.1 Used opamp representation 4.2.2 Sizing\n(5 Design 5.1 methods 5.1.1 Xschem 5.1.2 ngspice 5.1.3 KLayout 5.2 Process) siehe finn\n6 Discussion 6.1 Stability Analysis 6.2 Comparison 6.2.1 Python 6.2.2 Ideal 6.2.3 Real 6.3 is filter good?\n7 Conclusion and outlook",
    "crumbs": [
      "TOC (only temporary)"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html#motivation",
    "href": "content/_sec_introduction.html#motivation",
    "title": "TOC (only temporary)",
    "section": "Motivation",
    "text": "Motivation\nThe design and implementation of analog filters is a cornerstone in signal processing, with applications ranging from audio processing to communication systems. Among these, second order filters, like the biquad filter, are versatile building blocks due to its ability to realize four types of second order filters - low pass, high pass, band pass, and band stop. This project focuses on the integrated circuit (IC) design of a biquad filter, to get insight into the theoretical and practical engineering considerations behind IC design.\nFor a deeper understanding of IC design, this project does not rely on off-the-shelf operational amplifiers for the filter design, but aims to implement the entire filter architecture at the transistor level. This approach not only deepens the understanding of analog filter behavior but also introduces the challenges and intricacies of IC design, such as layout constraints, power efficiency, and stability.\nThis project demonstrates the design process of IC design from theorectical modelling, over simulation and design constraints to prototyping and to learn hands-on experience with tools used during the design process.",
    "crumbs": [
      "TOC (only temporary)"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html#scope-of-the-project",
    "href": "content/_sec_introduction.html#scope-of-the-project",
    "title": "TOC (only temporary)",
    "section": "Scope of the project",
    "text": "Scope of the project\nThe scope of this project is supposed to follow a real-world design flow, starting at a theorectical analysis of the specified filter and - in the best case - end in a tap-out of a prototype. If that stage is reached the prototype can be compared to the theorectical and simulation results obtained during the design process and checked for functionality.\nAs a tap-out of a prototype is fairly unrealistic in the time given, the goal is to simulate the specified filter with templates for operational amplifiers and base the IC layout on these templates.\nAll in all, this project includes a systems analysis if the specified filter, simulation results with ideal components and real components, taken from provided templates, and a physical layout prototype.",
    "crumbs": [
      "TOC (only temporary)"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html#specifications",
    "href": "content/_sec_introduction.html#specifications",
    "title": "TOC (only temporary)",
    "section": "Specifications",
    "text": "Specifications\n\n\n\n\n\n\nWarning\n\n\n\nNot sure if this is written in the correct time!?!\n\n\nThe main onjective is to design a universal biquad filter, based on the filter design proposed in the ASLK PRO Board Manual from Texas Instruments (Rao and Ravikumar 2012). The biquad filter shall have the following specifications:\n\\[\nf_0 = 1\\,kHz\n\\]\n\\[\nQ = 10\n\\]\nThe circuit design is done in Xschem and the simulation in ngspice. For the design on transistor level the 130nm CMOS technology SG13G2 is used. All these tools and PDk are integrated into a docker image IIC-OSIC-TOOLS (Pretl and Zachl 2025) provided by Prof. Dr. Harald Pretl from Johannes Keplar University.\nThis documentation provides a development report, which documents the design process with the taken steps and decisions made.",
    "crumbs": [
      "TOC (only temporary)"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html#test",
    "href": "content/_sec_introduction.html#test",
    "title": "TOC (only temporary)",
    "section": "Test",
    "text": "Test",
    "crumbs": [
      "TOC (only temporary)"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html#open-source",
    "href": "content/_sec_introduction.html#open-source",
    "title": "TOC (only temporary)",
    "section": "Open-Source",
    "text": "Open-Source\nAll the results of this report and development approach to design a Biquad are publicly available on GitHub (LINK…). Everyone is invited and should feel free to use, change, and share this work. This whole course and project wouldn’t be possible without the great Open-Source-Tools provided by the amazing community of layout designers, enthusiasts, and developers. Here a list with just a few of this programs: IC-OSIC-TOOLS, IHP Open PDK, Linux, Docker, Xschem, ngspice, KLayout, Quarto, Vim, Pandoc, TexLive, Python, Git, CoCalc, LibreOffice,\n\nHymne\nIn realms where code is free to fly, We build and share, our hearts reach high.  No walls, no locks, our wisdom streams,  In open light, we chase our dreams. \nSo sing the joy, the thrill, the spark,  In open source, we find our arc.  Together strong, we rise, explore—  In lines of code, forevermore. \n\n\n\n\nPretl, Harald, and Georg Zachl. 2025. “GitHub Repository of the IIC-OSIC-TOOLS.” Zenodo. https://doi.org/10.5281/zenodo.14634518.\n\n\nRao, K. R. K., and C. P. Ravikumar. 2012. Analog System Lab Kit PRO MANUAL. Texas Instruments.",
    "crumbs": [
      "TOC (only temporary)"
    ]
  },
  {
    "objectID": "content/_sec_theoretical_background.html",
    "href": "content/_sec_theoretical_background.html",
    "title": "2  Theoretical Background",
    "section": "",
    "text": "2.1 Biquad filter\nmy idea was to group all theoretics into one chapter, like a when the information becomes necessary during the quarto book, people can just jump back to this. we would circumvent having to introduce every little concept seperately whenever it comes up…\nThis chapter introduces the theory and core concepts necessary for IC design of a biquad filter. It is structured in a way, that it goes from the big picture to the small components. First, biquad filters are introduced with a focus on the universal biquad filter. After that, operational amplifiers come into the the foreground, as biquad filters make use of them in their circuits. Operational amplifiers are looked upon from an IC design standpoint.\nThe biquadratic filter, also known as the biquad filter, has its earliest implementation in the 1960s but is still in use today, most commonly in radio frequency receivers (Razavi 2018). In its application in RF-technology, it is used to remove unwanted neighboring signals ans noise (Razavi 2024). As biquad filter are second-order filters, they are also used as building blocks for higher filter implementations, by cascading them and adding first order filters (Rao and Ravikumar 2012).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theoretical Background</span>"
    ]
  },
  {
    "objectID": "content/_sec_theoretical_background.html#biquad-filter",
    "href": "content/_sec_theoretical_background.html#biquad-filter",
    "title": "2  Theoretical Background",
    "section": "",
    "text": "2.1.1 Universal biquad filter\nFor the filter design in this project, an universal biquad filter is used. The universal biquad filter is biquad filter variant with four operational amplifiers used in its design and the property of being able to be used in four different filter variants. Depending on the output of the universal biquad used, a low pass filter, high pass filter, band pass filter, or band stop filter will be implemented. This can be seen in (ref to figure of biquad fitler design). (Rao and Ravikumar 2012)\n\n\n\n\n\n\nFigure 2.1: circuit design of an universal biquad filter\n\n\n\nNOTE: change to png\nThe universal biquad filter consists of two non-inverting amplifiers working as adders in the circuit and two integrators. By setting \\(R\\) and \\(C\\) to specific values, the resonance frequency can be chosen. Other parameters adjustable in the universal biquad filter are the quality factor \\(Q\\) and the low-frequency gain \\(H_0\\). The quality factor and low-frequency gain determine the frequency response peaks of the low pass filter and the band pass filter. (Rao and Ravikumar 2012)\n\n\n2.1.2 Characteristics\nNOTE: no more than 3 subsections!\nAs the universal biquad filter is a second order filter with the specified outputs low pass, high pass, band pass, and band stop, each filter option can be described with a tranfer function on system level. The general second order transfer function is:\n\\[\nH(s) = \\frac{a_1 s^2 + b_1 s + c_1}{a_2 s^2 + b_2 s + c_2}\n\\tag{2.1}\\]\nThe coeffcients can be choosen so, that different responses, like low pass, high pass, band pass, and band stop are achieved.\nIn filter design a variant of this generalized transfer function is often choosen because it is easier describe the system by quality factor and angular frequency. Equation 2.2 is an exemplatory low pass filter with a transfer function specified for filter design. (Razavi 2018)\n\\[\nH(s) = \\frac{\\omega_n^2}{s^2 + \\frac{\\omega_n}{Q} s + \\omega_n^2}\n\\tag{2.2}\\]\n\\(Q\\) determines amoung other things the amount of peaking the transfer function has at the chosen frequency. ?lst-lowPassDifferentQ shows this graphically, the amout of peaking increases with increasing quality factor \\(Q\\).\n\n\nCode\n# Behavioral Analysis Biquad Filter\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initial values\nf0 = 1e3  # Resonance frequency in Hz\nw0 = 2 * np.pi * f0  # Angular frequency in rad/s\nQ1 = 1  # Quality factor\nQ2 = 2\nQ3 = 5\nQ4 = 10\nQ5 = 100\nH0 = 1  # Play around with this later\n\n# Logarithmic frequency axis\nfrequencies = np.logspace(2, 4, 10000)  # Frequency from 10^2 to 10^4 Hz\ns = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n\n############################################\n# Transfer functions of Active Filters\n############################################\n\n### Numerator\n# Low Pass Filter\nb_lp = H0\n\n# High Pass Filter\n#b_hp = (H0 * (s**2 / w0**2))\n\n# Band Pass Filter\n#b_bp = (-H0 * (s / w0))\n\n# Band Stop Filter\n#b_bs = -((1 + (s**2 / (w0**2))) * H0)\n\n# Denominator -&gt; for all filters the same\na0 = 1\na1_1 = (s / (w0 * Q1))\na1_2 = (s / (w0 * Q2))\na1_3 = (s / (w0 * Q3))\na1_4 = (s / (w0 * Q4))\na1_5 = (s / (w0 * Q5))\na2 = (s**2 / (w0**2))\n\nden1 = a0 + a1_1 + a2\nden2 = a0 + a1_2 + a2\nden3 = a0 + a1_3 + a2\nden4 = a0 + a1_4 + a2\nden5 = a0 + a1_5 + a2\n\n############################################\n# Calculation of the transfer functions H(s)\n############################################\nHs_lp_1 = b_lp / den1\nHs_lp_2 = b_lp / den2\nHs_lp_3 = b_lp / den3\nHs_lp_4 = b_lp / den4\nHs_lp_5 = b_lp / den5\n#Hs_hp = b_hp / den\n#Hs_bp = b_bp / den\n#Hs_bs = b_bs / den\n\n# Bode Diagram\nfig, axs = plt.subplots(2)\n#fig.suptitle(\"frequency response of biquad filter\")\n\n# Low Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp_1)), label='$Q = 1$')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp_1)) * (180 / np.pi), label='$Q = 1$')\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp_2)), label='$Q = 2$')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp_2)) * (180 / np.pi), label='$Q = 2$')\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp_3)), label='$Q = 5$')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp_3)) * (180 / np.pi), label='$Q = 5$')\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp_4)), label='$Q = 10$')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp_4)) * (180 / np.pi), label='$Q = 10$')\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp_5)), label='$Q = 100$')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp_5)) * (180 / np.pi), label='$Q = 100$')\n'''\n# High Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='high pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_hp)) * (180 / np.pi), label='high pass')\n\n# Band Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='band pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_bp)) * (180 / np.pi), label='band pass')\n\n# Band Stop Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='band stop')\naxs[1].semilogx(frequencies, (np.angle(Hs_bs)) * (180 / np.pi), label='band stop')\n'''\n#axs[0].title(\"amplitude response\")\naxs[0].set_xlabel(\"frequency/Hz\")\naxs[0].set_ylabel(\"amplitude/dB\")\n#axs[0].set_ylim(-50, 25)\naxs[0].grid(True, which=\"both\", ls=\"--\")\naxs[0].legend(loc=1)\n\n#axs[1].title(\"phase response\")\naxs[1].set_xlabel(\"frequency/Hz\")\naxs[1].set_ylabel(\"phase/deg\")\naxs[1].grid(True, which=\"both\", ls=\"--\")\naxs[1].legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nListing 2.1: Low pass filter with different quality factors\n\n\n\n\n\n\n\n\nThe height of the peak can be calculated with:\n\\[\nA_{peak} = \\frac{Q}{\\sqrt{1 - \\frac{1}{4Q^2}}}\n\\tag{2.3}\\]\nFor \\(Q = 100\\) the peak is \\(A_{peak} = 100.001\\), which converted into dB is \\(A_{peak,dB} = 40\\,dB\\), as is shown in ?fig-lowPassDifferentQ.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theoretical Background</span>"
    ]
  },
  {
    "objectID": "content/_sec_theoretical_background.html#operational-amplifier",
    "href": "content/_sec_theoretical_background.html#operational-amplifier",
    "title": "2  Theoretical Background",
    "section": "2.2 Operational Amplifier",
    "text": "2.2 Operational Amplifier\nAs seen in Figure 2.1 a Biquad Filter consists four Operational Amplifiers. To get a better understanding of these, this chaper will discuss the main arguments of OPAMS. There are different types of operational amplifiers that differ, for example, by their low- or high-impedance inputs and outputs. According to Schmid there exist nine diffrent types of the Opamps, but only four are mainly used (Schmid 2000). This is because almost always, the non-inverting (positive) input is designed as a high-impedance voltage input. The inverting (negative) input can either be a high-impedance voltage input or a low-impedance current input, depending on the type. Accordingly, the output can be either a low-impedance voltage output or a high-impedance current output. This results in four basic configurations, as shown in the accompanying table Table 2.1.\n\n\n\nTable 2.1: Four typicall Operational Amplifiers\n\n\n\n\n\n\n\n\n\n\n\nVoltage output\nCurrent output\n\n\n\n\nVoltage input\nVoltage-Feedback Amplifiers\nOperational Transconductance Amplifier\n\n\n\n\n\n\n\nCurrent input\nCurrent-Feedback Amplifiers\nCurrent Amplifier\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nAs a general rule, the simplest circuit that can do a job is usually the best choice. (H. Pretl and Michael Koefinger 2025)\n\n\n\n2.2.1 Voltage-Feedback Amplifiers (VFA)\nWhen discussing operational amplifiers (OPAMPs), most sources refer to the Voltage-Feedback Amplifier. These VFAs are voltage-controlled voltage sources, essentially acting as voltage boosters. They are characterized by a high-impedance input for both the non-inverting and inverting terminals, and a low-impedance voltage output. To realize various desired circuits, such as amplification, integration, addition/subtraction, etc…, these functions should ideally be achieved only through the surrounding circuitry. To meet this requirement, three main requirements need be satisfied:\n\nExtremely High Voltage Gain: Typically ranging from 60 to 120 dB (or a gain factor of \\(10^4\\) to \\(10^6\\)), this gain should be available over a wide frequency range.\nHigh Impedance at Differential Inputs: Ensuring minimal loading of the signal source.\nLow Impedance at the Output: Allowing the amplifier to drive various loads without significant voltage drop.\n\n\n\n\n\n\n\nDifference between a voltage source and a current source\n\n\n\nVoltage source\nA voltage source creates a constant voltage output by changing the output.\nCurrent source A current source creates a constant current by changing the voltage\nBoth of this sources can be explained by Ohms-Law: \\(R = \\frac{U}{I}\\). For example the voltage source: There is no influence of the load, so \\(R\\) may change and its value is unknown to the source. So to keep the voltage stable we can only change the current.\n\n\n\n\n2.2.2 Operational Transconductance Amplifier (OTA)\nIn the design process of the biquad only OTAs will be used, so the focus of this chapter will be on them. The operational transconductance amplifier puts out out a current proportional to its input voltage, unlike Voltage-Feedback Amplifiers REF:KAPITEL_VFA. In other words an OTA is a voltage controlled current source.\n\n\n\n\n\n\nFigure 2.2: Schematic symbol of an OTA (book-rotaktivefilter?)\n\n\n\nAs seen in the figure Figure 2.2 the OTA has the two differental inputs and the current output. On top of that it has a biasing current input \\(I_{bias}\\) which can control the\n\n2.2.2.1 Transconductance\nTransconductance is a fundamental parameter that describes the relationship between the input voltage and the output current in electronic devices, particularly in transistors and vacuum tubes. It is defined as the ratio of the change in output current to the change in input voltage, under conditions where all other variables are held constant. Mathematically, it is expressed as:\n\\[\ng_m = \\frac{\\Delta I_{out}}{\\Delta V_{in}}\n\\]\nwhere \\(g_m\\) is the transconductance, \\(\\Delta I_{out}\\) is the change in output current, and \\(\\Delta V_{in}\\) is the change in input voltage. The unit of transconductance is the siemens (S), which is equivalent to amperes per volt (A/V). Historically, it was also measured in “mhos,” which is “ohm” spelled backwards, reflecting its inverse relationship to resistance.\nThe term “transconductance” originates from the concept of “transfer conductance.” It combines the ideas of “transfer,” indicating the transfer of a signal from the input to the output, and “conductance,” which is the reciprocal of resistance and measures how easily a material conducts electric current. In essence, transconductance quantifies how effectively a device can convert a voltage change at its input into a proportional current change at its output.\nTransconductance is a crucial parameter in the design and analysis of electronic circuits, especially in amplifiers. In vacuum tubes and field-effect transistors (FETs), the transconductance determines the device’s ability to amplify signals. A higher transconductance value indicates a stronger amplification capability, as a small change in input voltage can result in a significant change in output current. This property makes transconductance a key factor in the performance and efficiency of various electronic devices and circuits.\n####HW 5-Transistor OTA\n\n\n\n2.2.3 Variants ?\nmaybe like miller opamp or something like that",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theoretical Background</span>"
    ]
  },
  {
    "objectID": "content/_sec_theoretical_background.html#mosfet-metal-oxide-semiconductor-field-effect-transistor",
    "href": "content/_sec_theoretical_background.html#mosfet-metal-oxide-semiconductor-field-effect-transistor",
    "title": "2  Theoretical Background",
    "section": "2.3 MOSFET (Metal-Oxide-Semiconductor Field-Effect-Transistor )",
    "text": "2.3 MOSFET (Metal-Oxide-Semiconductor Field-Effect-Transistor )\nTo get a general insight how an Operational Amplifier works and to uderstand the difference between a “off th shelf” part and a self made IC-Design, its nessesary to understand the main component: The MOSFET.\nTo be more precise, its nesessary to understand the behaviour of a MOSFET. Since were designing one from scratch, its possible to change the width W and leght L of the pysical layout. By doing this there is a lot of room for freedom and experimental space.\nBILD N-MOS\nBILD P-MOS\n\n2.3.1 Small-Signal Representation\n\n\n2.3.2 Sizing\nAs mentioned earlier we have several degrees of freedom in our design, like \\(W\\), \\(L\\), or the bias current \\(I_D\\). The problem is, that its extremly complex to describe a MOSFET mathmaticly and on top to that of change values to get a desired behaviour. Glady a wide used technique, which was introduced by P. Jespers and B. Murmann, is the \\(g_\\mathrm{m}/I_\\mathrm{D}\\) approach \\ref{Jesper…. Pretl 3).\nSaturation Saturation is a specific operation mode of a transistor. Its also called “ON mode”, because a channel between drain and source is created. This state is reached when the voltage \\(V_DS &gt;= (V_GS - V_th)\\). When this happens the drain-source current I_DS gets stable (saturates) and becomes nearly indipendet of V_DS. Still it can be very well controlled via V_GS, due to an effect called “pinch-off” (\\(\\ref{https://en.wikipedia.org/wiki/MOSFET}\\)).\nThe \\(g_\\mathrm{m}/I_\\mathrm{D}\\) method is primarly inteded to be used in saturated MOSFETs. To ensure this we keep the drain-source voltage as \\(V_ds = V_DD / 2\\).\n\n\n2.3.3 Current Mirror\n\n\n2.3.4 Differential Stage\n\n\n\n\nH. Pretl and Michael Koefinger. 2025. “Analog Circuit Design.” https://iic-jku.github.io/analog-circuit-design/.\n\n\nRao, K. R. K., and C. P. Ravikumar. 2012. Analog System Lab Kit PRO MANUAL. Texas Instruments.\n\n\nRazavi, Behzad. 2018. “The Biquadratic Filter.” IEEE Solid-State Circuit Magazine, 11–16.\n\n\n———. 2024. “The Design of a Biquadratic Filter.” IEEE Solid-State Circuit Magazine, 6–13.\n\n\nSchmid, H. 2000. “Approximating the Universal Active Element.” IEEE Transactions on Circuits and Systems II: Analog and Digital Signal Processing 47 (11): 1160–69. https://doi.org/10.1109/82.885124.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theoretical Background</span>"
    ]
  },
  {
    "objectID": "content/_sec_characterisation.html",
    "href": "content/_sec_characterisation.html",
    "title": "3  Characterisation",
    "section": "",
    "text": "3.1 Behauvioural Analysis and macro modelling\nthis chap is more about our biquad, and how we made it the way it is now\ni am failry open to discuss the exact contents of this chapter, as it is the one i am the most unsure about\nwe also need to excatly decide on where this chapter ends, as Finn will continue with chap 5 and the break between the chapters shall be as smooth as possible\nThe behauvioural analysis is done through macro modelling the universal biquad filter as a system. The system can be described with transfer functions and modelled with python.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Characterisation</span>"
    ]
  },
  {
    "objectID": "content/_sec_characterisation.html#behauvioural-analysis-and-macro-modelling",
    "href": "content/_sec_characterisation.html#behauvioural-analysis-and-macro-modelling",
    "title": "3  Characterisation",
    "section": "",
    "text": "3.1.1 Transfer Functions and frequency response\n\n\n\n\n\n\nWarning\n\n\n\nThis whole section needs to be reworked, I am not happy with the reading flow right now! -AvA\nI am going to shift the theory over to theory and only talk about the implementation…\n\n\nThe ASLK PRO Manual (Rao and Ravikumar 2012) provides the transfer functions of the four filter outputs: low pass, high pass, band pass, and band stop. The transfer functions are adaptations of the general second order transfer function as seen in Equation 2.1. (Razavi 2018)\nIn the following transfer function the input and output voltage are referenced according to Figure 2.1. The sections only contain their specific transfer function and frequency response.\n\n\n\n\n\n\nWarning\n\n\n\nplease recheck ALL TFs against manual for corecctness\n\n\n\n3.1.1.1 Low pass\nThe output if the low pass filter is marked in the circuit (Figure 2.1) as \\(LPF\\) and corresponds to \\(V_{03}\\) in the transfer function Equation 3.1.\n\\[\n\\frac{V_{03}}{V_i} = \\frac{H_0}{\\left( 1 + \\frac{s}{\\omega_0 Q} + \\frac{s^2}{\\omega_0^2} \\right)}\n\\tag{3.1}\\]\n?fig-freqResponseLowpass shows the amplitude and phase response of the low pass filter. The required frequency \\(f_0 = 1\\,kHz\\) and quality factor \\(Q = 10\\) recognizable in the bode plot. As the dc-gain was chosen to be \\(H_0 = 1\\), the low pass filter has a amplitude amplification of 1 in the lower frequencies.\n\n\nCode\n# Behavioral Analysis Biquad Filter\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initial values\nf0 = 1e3  # Resonance frequency in Hz\nw0 = 2 * np.pi * f0  # Angular frequency in rad/s\nQ = 10  # Quality factor\nH0 = 1  # Play around with this later\n\n# Logarithmic frequency axis\nfrequencies = np.logspace(2, 4, 10000)  # Frequency from 10^2 to 10^4 Hz\ns = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n\n############################################\n# Transfer functions of Active Filters\n############################################\n\n### Numerator\n# Low Pass Filter\nb_lp = H0\n\n# High Pass Filter\nb_hp = (H0 * (s**2 / w0**2))\n\n# Band Pass Filter\nb_bp = (-H0 * (s / w0))\n\n# Band Stop Filter\nb_bs = -((1 + (s**2 / (w0**2))) * H0)\n\n# Denominator -&gt; for all filters the same\na0 = 1\na1 = (s / (w0 * Q))\na2 = (s**2 / (w0**2))\n\nden = a0 + a1 + a2\n\n############################################\n# Calculation of the transfer functions H(s)\n############################################\nHs_lp = b_lp / den\nHs_hp = b_hp / den\nHs_bp = b_bp / den\nHs_bs = b_bs / den\n\n# Bode Diagram\nfig, axs = plt.subplots(2)\n#fig.suptitle(\"frequency response of biquad filter\")\n\n# Low Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp)), label='low pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp)) * (180 / np.pi), label='low pass')\n'''\n# High Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='high pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_hp)) * (180 / np.pi), label='high pass')\n\n# Band Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='band pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_bp)) * (180 / np.pi), label='band pass')\n\n# Band Stop Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='band stop')\naxs[1].semilogx(frequencies, (np.angle(Hs_bs)) * (180 / np.pi), label='band stop')\n'''\n#axs[0].title(\"amplitude response\")\naxs[0].set_xlabel(\"frequency/Hz\")\naxs[0].set_ylabel(\"amplitude/dB\")\naxs[0].set_ylim(-50, 25)\naxs[0].grid(True, which=\"both\", ls=\"--\")\n#axs[0].legend(loc=1)\n\n#axs[1].title(\"phase response\")\naxs[1].set_xlabel(\"frequency/Hz\")\naxs[1].set_ylabel(\"phase/deg\")\naxs[1].grid(True, which=\"both\", ls=\"--\")\n#axs[1].legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3.1: Frequency response of the low pass filter\n\n\n\n\n\nWith knowing the dc gain \\(H_0 = 1\\) and quality factot \\(Q = 10\\), the amplitude of the peak can be calculated as seen in Equation 2.3. Expression the value in dB, gives peak amplitude of \\(A_{peak,dB} = 20.002\\,dB\\) which corresponds to the peak value seen in ?fig-freqResponseLowpass.\n\n\n3.1.1.2 High pass\nThe output if the high pass filter is marked in the circuit (Figure 2.1) as \\(HPF\\) and corresponds to \\(V_{01}\\) in the transfer function Equation 3.2.\n\\[\n\\frac{V_{01}}{V_i} = \\frac{\\left( H_0 \\cdot \\frac{s^2}{\\omega_0^2} \\right)}{\\left( 1 + \\frac{s}{\\omega_0 Q} + \\frac{s^2}{\\omega_0^2} \\right)}\n\\tag{3.2}\\]\n?fig-freqResponseLowpass shows the amplitude and phase response of the high pass filter. The required frequency \\(f_0 = 1\\,kHz\\) and quality factor \\(Q = 10\\) recognizable in the bode plot. As the dc-gain was chosen to be \\(H_0 = 1\\), the low pass filter has a amplitude amplification of 1 in the higher frequencies.\n\n\nCode\n# Behavioral Analysis Biquad Filter\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initial values\nf0 = 1e3  # Resonance frequency in Hz\nw0 = 2 * np.pi * f0  # Angular frequency in rad/s\nQ = 10  # Quality factor\nH0 = 1  # Play around with this later\n\n# Logarithmic frequency axis\nfrequencies = np.logspace(2, 4, 10000)  # Frequency from 10^2 to 10^4 Hz\ns = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n\n############################################\n# Transfer functions of Active Filters\n############################################\n\n### Numerator\n# Low Pass Filter\nb_lp = H0\n\n# High Pass Filter\nb_hp = (H0 * (s**2 / w0**2))\n\n# Band Pass Filter\nb_bp = (-H0 * (s / w0))\n\n# Band Stop Filter\nb_bs = -((1 + (s**2 / (w0**2))) * H0)\n\n# Denominator -&gt; for all filters the same\na0 = 1\na1 = (s / (w0 * Q))\na2 = (s**2 / (w0**2))\n\nden = a0 + a1 + a2\n\n############################################\n# Calculation of the transfer functions H(s)\n############################################\nHs_lp = b_lp / den\nHs_hp = b_hp / den\nHs_bp = b_bp / den\nHs_bs = b_bs / den\n\n# Bode Diagram\nfig, axs = plt.subplots(2)\n#fig.suptitle(\"frequency response of biquad filter\")\n\n# Low Pass Filter\n#axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp)), label='low pass')\n#axs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp)) * (180 / np.pi), label='low pass')\n\n# High Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='high pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_hp)) * (180 / np.pi), label='high pass')\n'''\n# Band Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='band pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_bp)) * (180 / np.pi), label='band pass')\n\n# Band Stop Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='band stop')\naxs[1].semilogx(frequencies, (np.angle(Hs_bs)) * (180 / np.pi), label='band stop')\n'''\n#axs[0].title(\"amplitude response\")\naxs[0].set_xlabel(\"frequency/Hz\")\naxs[0].set_ylabel(\"amplitude/dB\")\naxs[0].set_ylim(-50, 25)\naxs[0].grid(True, which=\"both\", ls=\"--\")\n#axs[0].legend(loc=1)\n\n#axs[1].title(\"phase response\")\naxs[1].set_xlabel(\"frequency/Hz\")\naxs[1].set_ylabel(\"phase/deg\")\naxs[1].grid(True, which=\"both\", ls=\"--\")\n#axs[1].legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3.2: Frequency response of the high pass filter\n\n\n\n\n\n\n\n3.1.1.3 Band pass\nThe output for the band pass filter is marked as \\(BPF\\) in Figure 2.1. This denotes the point that is referenced in (eg-TFBandpass?) as \\(V_{02}\\).\n\\[\n\\frac{V_{02}}{V_i} = \\frac{\\left( - H_0 \\cdot \\frac{s}{\\omega_0} \\right)}{\\left( 1 + \\frac{s}{\\omega_0 Q} + \\frac{s^2}{\\omega_0^2} \\right)}\n\\tag{3.3}\\]\nThe band pass shown in ?fig-freqResponseBandpass has its center frequency at \\(1\\,kHz\\) as set in the requirements. Similarly to the low pass filter in ?fig-freqResponseLowpass and the high pass filter in ?fig-freqResponseHighpass the amplitude response peaks at this frequency, with its peak influenced by the quality factor.\n\n\nCode\n# Behavioral Analysis Biquad Filter\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initial values\nf0 = 1e3  # Resonance frequency in Hz\nw0 = 2 * np.pi * f0  # Angular frequency in rad/s\nQ = 10  # Quality factor\nH0 = 1  # Play around with this later\n\n# Logarithmic frequency axis\nfrequencies = np.logspace(2, 4, 10000)  # Frequency from 10^2 to 10^4 Hz\ns = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n\n############################################\n# Transfer functions of Active Filters\n############################################\n\n### Numerator\n# Low Pass Filter\nb_lp = H0\n\n# High Pass Filter\nb_hp = (H0 * (s**2 / w0**2))\n\n# Band Pass Filter\nb_bp = (-H0 * (s / w0))\n\n# Band Stop Filter\nb_bs = -((1 + (s**2 / (w0**2))) * H0)\n\n# Denominator -&gt; for all filters the same\na0 = 1\na1 = (s / (w0 * Q))\na2 = (s**2 / (w0**2))\n\nden = a0 + a1 + a2\n\n############################################\n# Calculation of the transfer functions H(s)\n############################################\nHs_lp = b_lp / den\nHs_hp = b_hp / den\nHs_bp = b_bp / den\nHs_bs = b_bs / den\n\n# Bode Diagram\nfig, axs = plt.subplots(2)\n#fig.suptitle(\"frequency response of biquad filter\")\n'''\n# Low Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp)), label='low pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp)) * (180 / np.pi), label='low pass')\n\n# High Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='high pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_hp)) * (180 / np.pi), label='high pass')\n'''\n# Band Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='band pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_bp)) * (180 / np.pi), label='band pass')\n\n# Band Stop Filter\n#axs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='band stop')\n#axs[1].semilogx(frequencies, (np.angle(Hs_bs)) * (180 / np.pi), label='band stop')\n\n#axs[0].title(\"amplitude response\")\naxs[0].set_xlabel(\"frequency/Hz\")\naxs[0].set_ylabel(\"amplitude/dB\")\naxs[0].set_ylim(-50, 25)\naxs[0].grid(True, which=\"both\", ls=\"--\")\n#axs[0].legend(loc=1)\n\n#axs[1].title(\"phase response\")\naxs[1].set_xlabel(\"frequency/Hz\")\naxs[1].set_ylabel(\"phase/deg\")\naxs[1].grid(True, which=\"both\", ls=\"--\")\n#axs[1].legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3.3: Frequency response of the band pass filter\n\n\n\n\n\n\n\n3.1.1.4 Band stop\nThe output for the band stop filter is marked in Figure 2.1 as \\(BSF\\) and in the transfer function as \\(V_{04}\\).\n\\[\n\\frac{V_{04}}{V_i} = \\frac{\\left( 1 + \\frac{s^2}{\\omega_0^2} \\right) \\cdot H_0}{\\left( 1 + \\frac{s}{\\omega_0 Q} + \\frac{s^2}{\\omega_0^2} \\right)}\n\\tag{3.4}\\]\n(Renner 2025) argues that Equation 3.4 from the ASLK PRO Manual (Rao and Ravikumar 2012) is incorrect, as using that equation produces inconsistent results. Using the negated form of Equation 3.4 as seen in Equation 3.5 seems to produce the correct output. Therefore Equation 3.5 will be used for further analysis.\n\\[\n\\frac{V_{04}}{V_i} = - \\frac{\\left( 1 + \\frac{s^2}{\\omega_0^2} \\right) \\cdot H_0}{\\left( 1 + \\frac{s}{\\omega_0 Q} + \\frac{s^2}{\\omega_0^2} \\right)}\n\\tag{3.5}\\]\n?fig-freqResponseBandstop shows the frequency response of the band stop, with its center frequency at \\(1\\,kHz\\).\n\n\nCode\n# Behavioral Analysis Biquad Filter\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initial values\nf0 = 1e3  # Resonance frequency in Hz\nw0 = 2 * np.pi * f0  # Angular frequency in rad/s\nQ = 10  # Quality factor\nH0 = 1  # Play around with this later\n\n# Logarithmic frequency axis\nfrequencies = np.logspace(2, 4, 10000)  # Frequency from 10^2 to 10^4 Hz\ns = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n\n############################################\n# Transfer functions of Active Filters\n############################################\n\n### Numerator\n# Low Pass Filter\nb_lp = H0\n\n# High Pass Filter\nb_hp = (H0 * (s**2 / w0**2))\n\n# Band Pass Filter\nb_bp = (-H0 * (s / w0))\n\n# Band Stop Filter\nb_bs = -((1 + (s**2 / (w0**2))) * H0)\n\n# Denominator -&gt; for all filters the same\na0 = 1\na1 = (s / (w0 * Q))\na2 = (s**2 / (w0**2))\n\nden = a0 + a1 + a2\n\n############################################\n# Calculation of the transfer functions H(s)\n############################################\nHs_lp = b_lp / den\nHs_hp = b_hp / den\nHs_bp = b_bp / den\nHs_bs = b_bs / den\n\n# Bode Diagram\nfig, axs = plt.subplots(2)\n#fig.suptitle(\"frequency response of biquad filter\")\n'''\n# Low Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp)), label='low pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp)) * (180 / np.pi), label='low pass')\n\n# High Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='high pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_hp)) * (180 / np.pi), label='high pass')\n\n# Band Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='band pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_bp)) * (180 / np.pi), label='band pass')\n'''\n# Band Stop Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='band stop')\naxs[1].semilogx(frequencies, (np.angle(Hs_bs)) * (180 / np.pi), label='band stop')\n\n#axs[0].title(\"amplitude response\")\naxs[0].set_xlabel(\"frequency/Hz\")\naxs[0].set_ylabel(\"amplitude/dB\")\naxs[0].set_ylim(-50, 25)\naxs[0].grid(True, which=\"both\", ls=\"--\")\n#axs[0].legend(loc=1)\n\n#axs[1].title(\"phase response\")\naxs[1].set_xlabel(\"frequency/Hz\")\naxs[1].set_ylabel(\"phase/deg\")\naxs[1].grid(True, which=\"both\", ls=\"--\")\n#axs[1].legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3.4: Frequency response of the band stop filter\n\n\n\n\n\n\n\n3.1.1.5 Comparison\nsome text…\n\n\nCode\n# Behavioral Analysis Biquad Filter\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initial values\nf0 = 1e3  # Resonance frequency in Hz\nw0 = 2 * np.pi * f0  # Angular frequency in rad/s\nQ = 10  # Quality factor\nH0 = 1  # Play around with this later\n\n# Logarithmic frequency axis\nfrequencies = np.logspace(2, 4, 10000)  # Frequency from 10^2 to 10^4 Hz\ns = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n\n############################################\n# Transfer functions of Active Filters\n############################################\n\n### Numerator\n# Low Pass Filter\nb_lp = H0\n\n# High Pass Filter\nb_hp = (H0 * (s**2 / w0**2))\n\n# Band Pass Filter\nb_bp = (-H0 * (s / w0))\n\n# Band Stop Filter\nb_bs = -((1 + (s**2 / (w0**2))) * H0)\n\n# Denominator -&gt; for all filters the same\na0 = 1\na1 = (s / (w0 * Q))\na2 = (s**2 / (w0**2))\n\nden = a0 + a1 + a2\n\n############################################\n# Calculation of the transfer functions H(s)\n############################################\nHs_lp = b_lp / den\nHs_hp = b_hp / den\nHs_bp = b_bp / den\nHs_bs = b_bs / den\n\n# Bode Diagram\nfig, axs = plt.subplots(2)\n#fig.suptitle(\"frequency response of biquad filter\")\n\n# Low Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp)), label='low pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_lp)) * (180 / np.pi), label='low pass')\n\n# High Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='high pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_hp)) * (180 / np.pi), label='high pass')\n\n# Band Pass Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='band pass')\naxs[1].semilogx(frequencies, np.unwrap(np.angle(Hs_bp)) * (180 / np.pi), label='band pass')\n\n# Band Stop Filter\naxs[0].semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='band stop')\naxs[1].semilogx(frequencies, (np.angle(Hs_bs)) * (180 / np.pi), label='band stop')\n\n#axs[0].title(\"amplitude response\")\naxs[0].set_xlabel(\"frequency/Hz\")\naxs[0].set_ylabel(\"amplitude/dB\")\naxs[0].set_ylim(-50, 25)\naxs[0].grid(True, which=\"both\", ls=\"--\")\naxs[0].legend(loc=1)\n\n#axs[1].title(\"phase response\")\naxs[1].set_xlabel(\"frequency/Hz\")\naxs[1].set_ylabel(\"phase/deg\")\naxs[1].grid(True, which=\"both\", ls=\"--\")\naxs[1].legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3.5: Behauvioural analysis of biquad filter\n\n\n\n\n\n\n\n\n3.1.2 Stability\nThe stability of the biquad is checked at different hierarchical levels. The first analysis considers the system from a theorectical standpoint with transfer functions, and checks if conceptual design of the biquad filter is stable. On a component level the stability of the integrators and adders is analyzed, to verify that the chosen values for resistors and capcitors do not induce oscillations through the feedback loop.\n(At last, the general stability of the OTA circuit itself needs to be checked, so that) &lt;- lets see what we can find for this…\n\n3.1.2.1 System stability\nA system is stable if its impulse response is absolutley integrateable. In case of a given transfer function, this can also be checked by calculating the poles of the transfer function. If all the poles lay in the left half of the s-plane, the system is considered stable. There is a special case where single poles can lay on the \\(j\\omega\\)-axis, on their own or in combination with poles in the left half of the s-plane. Systems which fall under that, are called marginally stable. (Fliege 1991)\n\n\n3.1.2.2 Pole-zero plot\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.signal import tf2zpk\n\n# Given values\nf = 1e3\nw = 2 * np.pi * f\nR = 1e3\nC = 1 / (w * R)\nQ = 10\nH0 = 1\n\n# Calculate w0\nw0 = 1 / (R * C)\n\n# Transfer function coefficients\na2 = 1 / w0**2\na1 = 1 / (w0 * Q)\na0 = 1\n\n# Define transfer functions manually as (numerator, denominator) pairs\nsystems = {\n    'Low pass filter': ([H0], [a2, a1, a0]),\n    'High pass filter': ([H0 / w0**2, 0, 0], [a2, a1, a0]),\n    'Band pass filter': ([-H0 / w0, 0], [a2, a1, a0]),\n    'Band stop filter': ([H0 / w0**2, 0, H0], [a2, a1, a0])\n}\n\n# Function to plot pole-zero map\ndef plot_pzmap(num, den, title, subplot_pos):\n    zeros, poles, _ = tf2zpk(num, den)\n    plt.subplot(2, 2, subplot_pos)\n    plt.plot(np.real(zeros), np.imag(zeros), 'go', label='Zeros')\n    plt.plot(np.real(poles), np.imag(poles), 'rx', label='Poles')\n    plt.axhline(0, color='gray', lw=0.5)\n    plt.axvline(0, color='gray', lw=0.5)\n    plt.title(title)\n    plt.xlim([-1500, 1500])\n    plt.ylim([-10000, 10000])\n    plt.grid(True)\n    plt.legend(loc='upper right')\n\n# Plot all systems\nplt.figure(figsize=(12, 10))\nfor i, (title, (num, den)) in enumerate(systems.items(), 1):\n    plot_pzmap(num, den, title, i)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3.6: Pole-zero plot for all transfer functions\n\n\n\n\n\n?fig-poleZeroStability shows the pole-zero plots of all four filters, low pass, high pass, band pass and band stop. In all four plots the poles are located in the left half of the s-plane and the system can therefore theoretically be classified as stable. (Razavi 2018) confirms this, as the article explains that with \\(Q \\rightarrow \\infty\\) the poles of the system approach the \\(j\\omega\\) axis and the system becomes unstable.\nThis analysis onbly considers the system as a mathematical model and as a whole. Further considerations regarding the stability of the components, integrators and adders, and the stability of the operational amplifiers themselves, have to be done.\n\n\n3.1.2.3 Component stability\nCircuits with opamps often have feedback loops, meaning that the output of the operational amplifier is somehow connected to the inverted input of the opamp. These feedback loops become problematic when the feedback signal is in phase with the input signal, as positive feedback is created and the circuit is working as an oscillator. (Reisch 2007)\nThe stability of the non-inverting amplifier can be verified by calculating the phase reserve \\(\\alpha\\) of the circuit. If \\(f_k\\) is the frequency where the feedback gain is equal to 1 and \\(\\varphi_k\\) is the corresponding phase to that frequency, then the phase reserve is calculated by:\n\\[\n\\alpha = 180° - \\varphi_k\n\\]\nFor circuits to be considered stable, the phase reserve has to be positive. To reduce overshoots during the transient response, it is customary to have a phase reserve of \\(\\alpha &gt; 45°\\). (Reisch 2007)\n\n\n\n\n\n\nFigure 3.7: Example of a transcient response of a circuit with a phase reserve of \\(\\alpha = 5.7°\\) (Reisch 2007)\n\n\n\nFigure (reisch) shows the transient response of a circuit with a phase reserve of $= 5.7°. The overshoots are clearly visible and number of the overshoots per puls are larger then the customary “one over, one under”-rule. As the phase reserve is positive, the figure shows that even though the transient response is not ideal, the oscillations are attenuated and the circuit is can be considered as stable.\nIn practical application, the phase reserve can be graphically determined with the help of bode diagrams. The bode diagram of the circuit with an open feedback loop is simulated, so that the frequency \\(f_k\\) can be read out. This is the frequnecy where the feedback gain is 1 or 0 dB. The corresponding frequency to that, is the phase of the feedback gain \\(\\varphi_k\\), the difference between \\(-180°\\) and \\(\\varphi_k\\) is the phase reserve \\(\\alpha\\). (Reisch 2007)\n\n\n\n\n\n\nWarning\n\n\n\nTalk abut which ota was used for stability analysis\n\n\n\n\n\n\n\n\nWarning\n\n\n\ninsert circuit where the stability analsis was done from, like in ltspice\n\n\n\n\n\n\n\n\nWarning\n\n\n\ninsert bode diagram figures (both: integrator and adder)\n\n\n\n\n\n\n\n\n\n\nFigure 3.8\n\n\n\n\n\nCode\n# Stability analysis adder\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sys\nsys.path.insert(0, '../simulation')\nimport ltspy3\n\nsd=ltspy3.SimData('../simulation/stability_adder.raw',[b'v(v_out)',b'frequency'])\n\nnvout = sd.variables.index(b'v(v_out)')\nnfrequency = sd.variables.index(b'frequency')\n\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 6), sharex=True)\n\nax1.semilogx(sd.values[nfrequency],20*np.log10(abs(sd.values[nvout])))\nax1.set_ylabel(\"Magnitude/dB\")\nax1.axvline(3e5,color='red',linestyle='--')\nax1.grid(True, which=\"both\", ls=\"--\")\n\nax2.semilogx(sd.values[nfrequency],np.angle(sd.values[nvout], deg=True))\nax2.axvline(3e5,color='red',linestyle='--')\nax2.axhline(82.75,color='red',linestyle='--')\nax2.set_ylabel(\"Phase/deg\")\nax2.set_xlabel(\"Frequency/Hz\")\n\n\nplt.grid(True, which=\"both\", ls=\"--\")\nplt.tight_layout()\nplt.show()\n\n\n/opt/anaconda3/lib/python3.11/site-packages/matplotlib/cbook.py:1699: ComplexWarning:\n\nCasting complex values to real discards the imaginary part\n\n/opt/anaconda3/lib/python3.11/site-packages/matplotlib/cbook.py:1345: ComplexWarning:\n\nCasting complex values to real discards the imaginary part\n\n\n\n\n\n\n\n\n\nFigure 3.9: Stability analysis of the adder\n\n\n\n\n\n\n\nCode\n# Stability analysis integrator\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sys\nsys.path.insert(0, '../simulation')\nimport ltspy3\n\nsd=ltspy3.SimData('../simulation/stability_integrator.raw',[b'v(v_out)',b'frequency'])\n\nnvout = sd.variables.index(b'v(v_out)')\nnfrequency = sd.variables.index(b'frequency')\n\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 6), sharex=True)\n\nax1.semilogx(sd.values[nfrequency],20*np.log10(abs(sd.values[nvout])))\nax1.set_ylabel(\"Magnitude/dB\")\nax1.axvline(7e5,color='red',linestyle='--')\nax1.grid(True, which=\"both\", ls=\"--\")\n\nax2.semilogx(sd.values[nfrequency],np.angle(sd.values[nvout], deg=True))\nax2.axvline(7e5,color='red',linestyle='--')\nax2.axhline(68,color='red',linestyle='--')\nax2.set_ylabel(\"Phase/deg\")\nax2.set_xlabel(\"Frequency/Hz\")\n\nplt.grid(True, which=\"both\", ls=\"--\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3.10: Stability analysis of the integrator\n\n\n\n\n\nIn the following figures (ref) and ?fig-stabilityIntegrator this method was used to determine the stability over the phase reserve.\n(add here part about whether they are stable…)\nThe stability of the integrator circuit, as seen in ?fig-stabilityIntegrator, shows a intersection of the magnitude plot with the \\(0\\,dB\\) line at about \\(f_k = 70\\,kHz\\), which corresponds to a phase of \\(\\varphi_k = 68°\\). This would leave a phase reserve of:\n\\[\n\\alpha_{int} = 180° - \\varphi_k = 112° &gt; 45°\n\\]\nTherefore the integrator would be stable.\n\n\n3.1.2.4 OTA stability\ni have not found anything in pretl script, but i clearly remember mr. meiners talking about this…\ni have found something in pretls script, but looks not easy… look at chapter about mosfets\n\n\n\n3.1.3 Ideal Opamp\nkinda forgot where I wanted to go with this one… ehhh maybe it will come back\nuhhh i think it was about the ideal circuit and spice analysis etc\nTo check the behauviour of the implemented circuit against the modelled behauviour of the transfer function, the universal biquad was built as an ideal circuit with voltage-regulated current sources instead of OTAs.\n\n\nCode\n# plot Ideal (voltage controlled current? source) biquad\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sys\nsys.path.insert(0, '../simulation')\nimport ltspy3\n\nsd=ltspy3.SimData('../simulation/biquad_univ.raw')\n\nnvoutLPF = sd.variables.index(b'v(lpf)')\nnvoutHPF = sd.variables.index(b'v(hpf)')\nnvoutBPF = sd.variables.index(b'v(bpf)')\nnvoutBSF = sd.variables.index(b'v(bsf)')\nnfrequency = sd.variables.index(b'frequency')\n\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 6), sharex=True)\n\nax1.semilogx(sd.values[nfrequency],20*np.log10(abs(sd.values[nvoutLPF])),label='lpf')\nax1.semilogx(sd.values[nfrequency],20*np.log10(abs(sd.values[nvoutHPF])),label='hpf')\nax1.semilogx(sd.values[nfrequency],20*np.log10(abs(sd.values[nvoutBPF])),label='bpf')\nax1.semilogx(sd.values[nfrequency],20*np.log10(abs(sd.values[nvoutBSF])),label='bsf')\nax1.set_xlim([10e1,10e3])\nax1.set_ylim([-40,20])\nax1.set_ylabel(\"Magnitude/dB\")\nax1.grid(True, which=\"both\", ls=\"--\")\nax1.legend()\n\nax2.semilogx(sd.values[nfrequency],np.angle(sd.values[nvoutLPF], deg=True),label='lpf')\nax2.semilogx(sd.values[nfrequency],np.angle(sd.values[nvoutHPF], deg=True),label='hpf')\nax2.semilogx(sd.values[nfrequency],np.angle(sd.values[nvoutBPF], deg=True),label='bpf')\nax2.semilogx(sd.values[nfrequency],np.angle(sd.values[nvoutBSF], deg=True),label='bsf')\nax2.set_ylabel(\"Phase/deg\")\nax2.set_xlabel(\"Frequency/Hz\")\nax2.legend()\n\nplt.grid(True, which=\"both\", ls=\"--\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3.11: Simulation of an idealised biquad\n\n\n\n\n\nhere plot comp between python and ideal\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sys\nsys.path.insert(0, '../simulation')\nimport ltspy3\n\nsd=ltspy3.SimData('../simulation/biquad_univ.raw')\n\nnvoutLPF = sd.variables.index(b'v(lpf)')\nnvoutHPF = sd.variables.index(b'v(hpf)')\nnvoutBPF = sd.variables.index(b'v(bpf)')\nnvoutBSF = sd.variables.index(b'v(bsf)')\nnfrequency = sd.variables.index(b'frequency')\n\n#behauvioural moddling with tfs\n\n# Initial values\nf0 = 1000  # Resonance frequency in Hz\nw0 = 2 * np.pi * f0  # Angular frequency in rad/s\nQ = 10  # Quality factor\nH0 = 1  # Play around with this later\n\n# Logarithmic frequency axis\nfrequencies = np.logspace(0, 4, 1000)  # Frequency from 10^2 to 10^4 Hz\ns = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n\n############################################\n# Transfer functions of Active Filters\n############################################\n\n\n### Numerator\n# Low Pass Filter\nb_lp = H0\n\n# High Pass Filter\nb_hp = (H0 * (s**2 / w0**2))\n\n# Band Pass Filter\nb_bp = (-H0 * (s / w0))\n\n# Band Stop Filter\nb_bs = -(1 + (s**2 / (w0**2))) * H0\n\n# Denominator -&gt; for all filters the same\na0 = 1\na1 = (s / (w0 * Q))\na2 = (s**2 / (w0**2))\n\nden = a0 + a1 + a2\n\n############################################\n# Calculation of the transfer functions H(s)\n############################################\nHs_lp = b_lp / den\nHs_hp = b_hp / den\nHs_bp = b_bp / den\nHs_bs = b_bs / den\n\n#mag plots\n\nfig, axs = plt.subplots(2, 2, sharex=True, sharey=True)\n\nax1, ax2, ax3, ax4 = axs.flatten()\n\n# Plotting each\nax1.semilogx(frequencies, 20 * np.log10(np.abs(Hs_lp)), label='tf')\nax1.semilogx(sd.values[nfrequency], 20 * np.log10(abs(sd.values[nvoutLPF])), label='ngspice')\nax1.set_ylabel(\"magnitude/dB\")\nax1.set_title(\"low pass filter\")\nax1.set_xlim([10,10e3])\nax1.set_ylim([-40,25])\nax1.grid(True, which=\"both\", ls=\"--\")\nax1.legend()\n\nax2.semilogx(frequencies, 20 * np.log10(np.abs(Hs_hp)), label='tf')\nax2.semilogx(sd.values[nfrequency], 20 * np.log10(abs(sd.values[nvoutHPF])), label='ngspice')\nax2.set_title(\"high pass filter\")\n#ax2.set_xlim([10,10e3])\n#ax2.set_ylim([-40,25])\nax2.grid(True, which=\"both\", ls=\"--\")\nax2.legend()\n\nax3.semilogx(frequencies, 20 * np.log10(np.abs(Hs_bp)), label='tf')\nax3.semilogx(sd.values[nfrequency], 20 * np.log10(abs(sd.values[nvoutBPF])), label='ngspice')\nax3.set_xlabel(\"frequency/Hz\")\nax3.set_ylabel(\"magnitude/dB\")\nax3.set_title(\"band pass filter\")\n#ax3.set_xlim([10,10e3])\n#ax3.set_ylim([-40,25])\nax3.grid(True, which=\"both\", ls=\"--\")\nax3.legend()\n\nax4.semilogx(frequencies, 20 * np.log10(np.abs(Hs_bs)), label='tf')\nax4.semilogx(sd.values[nfrequency], 20 * np.log10(abs(sd.values[nvoutBSF])), label='ngspice')\nax4.set_xlabel(\"frequency/Hz\")\nax4.set_title(\"band stop filter\")\n#ax4.set_xlim([10,10e3])\n#ax4.set_ylim([-40,25])\nax4.grid(True, which=\"both\", ls=\"--\")\nax4.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sys\nsys.path.insert(0, '../simulation')\nimport ltspy3\n\nsd=ltspy3.SimData('../simulation/biquad_univ.raw')\n\nnvoutLPF = sd.variables.index(b'v(lpf)')\nnvoutHPF = sd.variables.index(b'v(hpf)')\nnvoutBPF = sd.variables.index(b'v(bpf)')\nnvoutBSF = sd.variables.index(b'v(bsf)')\nnfrequency = sd.variables.index(b'frequency')\n\n#behauvioural moddling with tfs\n\n# Initial values\nf0 = 1000  # Resonance frequency in Hz\nw0 = 2 * np.pi * f0  # Angular frequency in rad/s\nQ = 10  # Quality factor\nH0 = 1  # Play around with this later\n\n# Logarithmic frequency axis\nfrequencies = np.logspace(0, 4, 1000)  # Frequency from 10^2 to 10^4 Hz\ns = 1j * 2 * np.pi * frequencies  # Laplace-Variable s = jω\n\n############################################\n# Transfer functions of Active Filters\n############################################\n\n\n### Numerator\n# Low Pass Filter\nb_lp = H0\n\n# High Pass Filter\nb_hp = (H0 * (s**2 / w0**2))\n\n# Band Pass Filter\nb_bp = (-H0 * (s / w0))\n\n# Band Stop Filter\nb_bs = -(1 + (s**2 / (w0**2))) * H0\n\n# Denominator -&gt; for all filters the same\na0 = 1\na1 = (s / (w0 * Q))\na2 = (s**2 / (w0**2))\n\nden = a0 + a1 + a2\n\n############################################\n# Calculation of the transfer functions H(s)\n############################################\nHs_lp = b_lp / den\nHs_hp = b_hp / den\nHs_bp = b_bp / den\nHs_bs = b_bs / den\n\n#phase plots\n\nfig, axs = plt.subplots(2, 2, sharex=True, sharey=True)\n\nax1, ax2, ax3, ax4 = axs.flatten()\n\n# Plotting each\nax1.semilogx(frequencies, np.angle(Hs_lp, deg=True), label='tf')\nax1.semilogx(sd.values[nfrequency],np.angle(sd.values[nvoutLPF], deg=True),label='ngspice')\nax1.set_ylabel(\"phase/deg\")\nax1.set_title(\"low pass filter\")\nax1.set_xlim([10,10e3])\n#ax1.set_ylim([-40,25])\nax1.grid(True, which=\"both\", ls=\"--\")\nax1.legend()\n\nax2.semilogx(frequencies, np.angle(Hs_hp, deg=True), label='tf')\nax2.semilogx(sd.values[nfrequency],np.angle(sd.values[nvoutHPF], deg=True),label='ngspice')\nax2.set_title(\"high pass filter\")\n#ax1.set_xlim([10,10e3])\n#ax1.set_ylim([-40,25])\nax2.grid(True, which=\"both\", ls=\"--\")\nax2.legend()\n\nax3.semilogx(frequencies, np.angle(Hs_bp, deg=True), label='tf')\nax3.semilogx(sd.values[nfrequency],np.angle(sd.values[nvoutBPF], deg=True),label='ngspice')\nax3.set_xlabel(\"frequency/Hz\")\nax3.set_ylabel(\"phase/deg\")\nax3.set_title(\"band pass filter\")\n#ax1.set_xlim([10,10e3])\n#ax1.set_ylim([-40,25])\nax3.grid(True, which=\"both\", ls=\"--\")\nax3.legend()\n\nax4.semilogx(frequencies, np.angle(Hs_bs, deg=True), label='tf')\nax4.semilogx(sd.values[nfrequency],np.angle(sd.values[nvoutBSF], deg=True),label='ngspice')\nax4.set_xlabel(\"frequency/Hz\")\nax4.set_title(\"band stop filter\")\n#ax1.set_xlim([10,10e3])\n#ax1.set_ylim([-40,25])\nax4.grid(True, which=\"both\", ls=\"--\")\nax4.legend()\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Characterisation</span>"
    ]
  },
  {
    "objectID": "content/_sec_characterisation.html#implementation-or-real-circuit",
    "href": "content/_sec_characterisation.html#implementation-or-real-circuit",
    "title": "3  Characterisation",
    "section": "3.2 Implementation (or Real Circuit)",
    "text": "3.2 Implementation (or Real Circuit)\nthis is about the transition from the ideal circuit to real circuit\n\n3.2.1 used opamp representation\nlike with opamp did we use specifically (5 ota i think), why, what are special about that\n\n\n3.2.2 Sizing\nwith the script from pretl, if i remember correctly\n\n\n\n\nFliege, Norbert. 1991. Systhemtheorie. 1st ed. Stuttgart: Teubner.\n\n\nRao, K. R. K., and C. P. Ravikumar. 2012. Analog System Lab Kit PRO MANUAL. Texas Instruments.\n\n\nRazavi, Behzad. 2018. “The Biquadratic Filter.” IEEE Solid-State Circuit Magazine, 11–16.\n\n\nReisch, Michael. 2007. Elektronische Bauelemente - Funktion, Grundschaltungen, Modellierung Mit SPICE. 2nd ed. Stuttgart: Springer-Verlag.\n\n\nRenner, Nils. 2025. “Biquadratic IIR (SOS) Filters.”",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Characterisation</span>"
    ]
  },
  {
    "objectID": "content/_sec_finns_part.html",
    "href": "content/_sec_finns_part.html",
    "title": "4  Preamble to the Schematic",
    "section": "",
    "text": "4.1 Designing the ideal circuit\nBefore designing it was necessary to understand the main workflow of the tool chain. The schematic design program is called Xschem. This tool allows for a graphical representation of the netlist, like other discreet ECAD software. The main difference between discreet tools and integrated tools like Xschem are the devices that are placed within the schematic.\nWhile in discreet circuit design all ICs are just “blackbox”-symbols, Xschem introduces a concept called hierarchical design. As most integrated circuits are made from mosfets, resistors and capacitors, these are within the symbol of for example the OTA. This increases the complexity a lot especially when naming conventions are not followed. As a guideline for naming conventions we used the “designers etiquette” provided by Professor Pretel.\nThe original circuit was copied out of the ASLK Pro Board Manual Experiment 4. This source provided both the ideal schematic and the means to calculate the resistive and reactive elements. The calculation of the capacitors and some of the resistors is based on the following formulas:\nIn contrast to board level design simulating the schematic meant replacing the discrete operational amplifiers with small signal models. One of the lab tutors suggested using voltage controlled current sources as they were easier to handle.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Preamble to the Schematic</span>"
    ]
  },
  {
    "objectID": "content/_sec_finns_part.html#designing-the-real-circuit",
    "href": "content/_sec_finns_part.html#designing-the-real-circuit",
    "title": "4  Preamble to the Schematic",
    "section": "4.2 Designing the real circuit",
    "text": "4.2 Designing the real circuit\nWhile the ideal circuit was based an ideal voltage controlled current source, the real circuit needed to implement these as OTAs at a lower hierarchal level. The current source was replaces by the 5T- OTA. This five-transistor model is the smallest implementation of an OTA. The schematic was sourced out of the script by Professor Pretel. This implementation is based on 3 parts.\n\nThe OTA consists of 3 stages. M1 and M2 form the differential input pair. They are powered by a current mirror which is formed by M3 and M4. This allows the positive input to mirror its current to summative point at the drain of M4. To bias the circuit the gate of the transistor M5 is connected to a diode connected Mosfet. This allows for a stable current to power the biasing transistor M5.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Preamble to the Schematic</span>"
    ]
  },
  {
    "objectID": "content/_sec_finns_part.html#introduction-into-the-fundamentals-of-integrated-layouting.",
    "href": "content/_sec_finns_part.html#introduction-into-the-fundamentals-of-integrated-layouting.",
    "title": "4  Preamble to the Schematic",
    "section": "5.1 1.1 Introduction into the fundamentals of integrated layouting.",
    "text": "5.1 1.1 Introduction into the fundamentals of integrated layouting.\nBefore designing a on the wafer, the basics of the design process must be understood. To that end an explanation of the software as well as the physical layers is necessary to comprehend the design challenges.\nWhen designing an integrated chip, the designer first needs to choose a technology. Each technology has different design rules and properties, which makes it suitable for the application. A technology usually comes with a process design kit (PDK). A PDK contains a device library, verification checks and technology data.\nThe device library contains the symbols used in the schematic and the PCells/devices used in the layout. The verification checks consist of the design rule check (DRC) as well as the layout vs. schematic (LVS). The technology data represents the basis of DRC and defines the physical constraints of the technology.\nThe used technology was the sg13g2 technology from IHP. Which is a BiCMOS technology with a 130nm minimum gate length. This PDK is open source and in a preview status.\nTo design the layout itself one first needs to be familiar with the different masks and the structure of a waver. The following is a simplified explanation of the different layers, their use and the manufacturing process behind it. For this report this is kept simple and will only focus on the layers used in the design.\nThe base is the bulk and a field oxide (FOX) layer on top of it. In this technology the bulk is a p-substrate. The FOX layer is an insulator, which separates devices from one another.\nTo make a device first the FOX layer needs to be opened. That is done by etching away the FOX. The active mask allows the designer to specify the areas where the FOX will be opened. This is necessary for the doping process, which is usually done by an n- or p-select mask. In sg12g2 the n-select mask does not need to be specified. It is necessary to remove the FOX, otherwise the doping specified in the n-select mask will be stopped by the FOX. The select mask also needs to be bigger than the Active mask due to misalignment during the manufacturing process.\n\nFigure : Doping process of the substrate\nThe next layer is the poly layer. The poly layer forms the gate of the transistors, the name is an abbreviation for Polysilicon. The poly can be routed like normal metal layers, with the exception that it is for more restive than the metal layers, so caution is advised for long poly traces.\nIn the manufacturing process the thick poly layer prevents the n-select mask to dope the part below the gate, therefore creating the drain and source regions of the nmos.\n\n\n\nFigure : Manufacturing the poly layer in the process\n\n\nAlso note that the drain and source contacts are interchangeable, as they are identical regions in the active area. The last two pictures showed how an NMOS device is formed. As mentioned before, the n-select mask doesn’t exist in the used PDK, but the p-select mask does exist with the label pSD.\nAs the PMOS is a negated NMOS, the designer first needs to place the p+ regions in an n-substrate. This is done by enveloping the transistor in an NWell. The NWell is a region that can be specified by the designer and works like an implant in the substrate. The FOX is also opened by the active layer but pSD layer is used to implant the p+ region.\n\n\n\nSide view of an PMOS transistor\n\n\nThe N- or PMOS is formed in the bulk, but there are no electrical connections to the pins of the device. Connections between devices can be established using the poly or active layer, but both options are not advised. Therefore, the first metal layer is used for connections between devices. Connections from an active or poly layer region to the metal layer can´t be made by overlaying the layers as they are separated by an insulator. To connect these different layers the contact layer (Cnt) is used. It connects active or poly layer to the metal 1 layer, by removing the insulator over these regions. Note that the first connection between these regions is always over the metal 1 layer. To switch between the different Metal layers, vias can be used, similar to a multilayer PCB design. These vias are formed by opening the insulator and placing in an conductor like tungsten the opening.\n\n\n\nMetal connection to the drain and source contacts\n\n\nThe MOSFET is a 4-pin device, consisting of source, gate, drain and body. While the body often is omitted on a schematic level, in the integrated layout the body of the MOSFET need to be tied to a defined potential. The body is also called the substrate or bulk, in case of a PMOS it is the NWell.\nFor the nmos this means connecting the substrate to VSS, while the NWell of a PMOS will be pulled to VDD. To have multiple locations to where the bulk or NWell connected to their potentials is advised.\nThe later chapters will work in the sg13g2 technology, the knowledge acquired in this chapter can be mapped to this technology. The figure 5 compares the technology on the left, with the learned knowledge on the right. Note that the PWell is not used for NMOS devices only for ties.\n\n\n\nayer comparison between IHP and theory",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Preamble to the Schematic</span>"
    ]
  },
  {
    "objectID": "content/_sec_finns_part.html#klayout",
    "href": "content/_sec_finns_part.html#klayout",
    "title": "4  Preamble to the Schematic",
    "section": "5.2 KLayout",
    "text": "5.2 KLayout\nThe previous chapter described the fundamentals of the integrated layout, in this chapter these fundamentals are put into practice to create the layout for the 5T-OTA outlined by the schematic by Haraled Pretel(see)\nThe schematic outlined by Professor Pretel consists of 13 N- and PMOS devices. These devices are defined within the PDK and are the fundamental blocks, which make up the layout within the technology. Within the layout software these are defined as PCells. As the schematic designer works out the optimal design, one of the main variables to change the behaviour of the MOSFETs, is the w/l ratio. This ratio defines the width and length of the gate over the active area. These w/l ratios are crucial to the layout process, as they define the physical size of the devices. In the layout the w/l values were given by the calculation of Professor Pretel. These w/l ratios will be used to configure the PCells.\nThe layout program used is called KLayout. Similar to Xschem it works in a strict hierarchical system. As the layout of the 5T-OTA will be used in the Top-Level layout of the Biquad, the 5T-OTA itself is a cell, that can be called multiple times, throughout the layout of the Top-Level. To make it easier for the designer to connect the individual components of the Top-Level together, the 5T-OTA just uses the metal 1 layer. The interface points are the vias stacks. Therefore, making connections on the higher layers easier, as the individual cells for the 5T-OTA only reside on the most bottom layer.\nIn the following chapters DRC and LVS will be important concepts. DRC (Desing Rule Check) describes the process of comparing the physical layout to the constrains of the technology. This will throw an error, for example if a “trace” on the Metal1 layer is too thin. LVS (Layout Versus Schematic) describes the process of comparing the schematic to the layout. This will throw an error when two nets are shorted or a device it not correctly connected.\n\n5.2.1 The Setup of KLayout\nWhile the previous chapters showed only a cross section of the waver, the designer only sees the waver from a top view, but needs to recall the cross section, while working on the layout. This especially true for the layer that can be used as conductors.\nThis chapter will explain how to set up KLayout and the tools necessary to run DRC and LVS. It also shows an example way for a simple workflow.\nBefore the layout process begins it is paramount aggravate all the data files necessary. To do that create a new folder labelled Layout and copy your schematic design into this folder. Consider renaming your schematic into letters only. Do not use special character similar to UNIX symbols, only underscores are permitted.\nTo create a valid netlist, open the schematic in Xschem. Under simulation-&gt;LVS make sure that “LVS netlist + Top level is a .subckt” and “Upper case .SUBCKT and .ENDS” is selected.\nAfter selecting these options, run the netlist and simulation. In the folder structure a new folder labelled simulations with file named “YOUR_PROJECT.spice” should appear. Copy that file into your main layout directory.\nTo begin designing create a new layout file called the same as the schematic by running “Klayout -e”. The argument -e opens Klayout in editing mode. To make the editing mode default, select File-&gt;Setup-&gt;Application-&gt;Editing Mode-&gt;Use editing mode by default.\nTo create a new layout, select “New Layout”. A wizard should appear that allows the selection of the technology. It is important to rename the Top Cell to match the name of your schematic so “YOUR_PROJECT”.\nPlease note that all the scripts later used are case sensitive, so consider this when renaming files.\nUpon first saving, select the GDS file standard and name your file YOUR_PROJECT.GDS. The main layout directory should now contain YOUR_PROJECT.sch/.spice/.gds files. As well as a simulation folder. Now create a folder called LVS in this main layout directory.\nFor ease of access, create shell-script in your main layout folder to run LVS. The command saved with in the file should be:\npython /foss/pdks/ihp-sg13g2/libs.tech/klayout/tech/lvs/run_lvs.py --netlist= YOUR_PROJECT.spice --layout= YOUR_PROJECT.gds --run_dir=LVS/\nTry running this command, to ensure it runs correctly. If it fails, saying something about “use_same_circuit”, check the names of your files, including the cell name of your layout. It’s crucial that all files are named the same.\nThis script will produce a. lvsdb file in the LVS directory. This file contains the comparison between the netlist of the schematic, as well as the extracted netlist of the layout.\nAs the design process is a constant back and forth with design and running LVS and DRC, these steps are necessary to ensure a good workflow.\nBefore designing we need to set up the tools in Klayout. For the DRC, open Macros-&gt;Macro Development and select DRC-&gt;[Technology sg13g2]-&gt;sg13g2_maximal. Copy the contents of this script and paste them into a new DRC script. Running this script will provide the “Marker Database Brower” from which the individual DRC errors can be selected. As the error names and a semi-detailed description can be found the “SG13G2_os_layout_rules.pdf” on the Github of IHP (see).\nTo run LVS run the shell script and open the netlist browser under Tool-&gt;Netlist Browser. To see the LVS errors click on file-&gt;open and then navigate to /LVS/YOUR_PROJECT.lvsdb. This only needs to be done one time, as the LVS shell script will override the current .lvsdb file, when run anew. Select File-&gt;Reload to get the current LVS-data.\nAfter loading the .lvsdb file the cross-reference tab will show the discrepancies between the netlists. This is because no layout has been created yet.\nSome quality-of-life options:\n\nTo provide a better overview of the used layers, right click on the right-hand side layer tab to open a pop up menu and select “hide empty layers”.\nDisabling navigation by holding the middle mouse button: Check File-&gt;Setup-&gt;Navigation-&gt;Zoom and Pan-&gt;Mouse alt mode. This allows the control more similar to Autodesk Fusion or KiCad.\nDisabling the zoom when pasting: File-&gt;Setup-&gt;Navigation-&gt;Zoom and select Pan-&gt;On paste-&gt;Pan to pasted objects. This option disables the full zoom to object, which can cause disorientation.\nTo show all the hierarchy and layers select Display-&gt;Full Hierarchy\nTo change to dark mode select File-&gt;Setup-&gt;Display-&gt;Background-&gt;Background Color-&gt;#42\n\nThe real layout process can now begin in Klayout. Different from PCB design, the symbols on the schematic side do not need to be matched to a footprint. Rather the symbol are the fundamental devices in the technology. To work with the devices of the technology open the library on the down-left under Libraries-&gt;SG13_dev. The list below shows the usable devices. By dragging and dropping them into the design, the devices are placed in the layout.\nIn previous chapters mentioned the w/l ratios will now play a role as the individual devices are configured. To configure a device or PCells, double click it and navigate to PCell parameters and enter the W/L ratios. Updating the PCell will change the device to the desired parameters.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Preamble to the Schematic</span>"
    ]
  },
  {
    "objectID": "content/_sec_finns_part.html#the-layout-process",
    "href": "content/_sec_finns_part.html#the-layout-process",
    "title": "4  Preamble to the Schematic",
    "section": "5.3 The Layout Process",
    "text": "5.3 The Layout Process\nThe workflow is much more incremental than in PCB design, as one implements device by device.\nTo that end, it is practical to copy the original schematic and delete the already placed devices, to maintain an overview of the progress. After every two to three cells, it is advised to run LVS and DRC.\nPlacing and configuring a device was already described, connecting devices is usually done by the Metal1 layer. It is advised to work with the metal layer alongside the hierarchy. So for the top level use the higher metal layers like Metal3 to Metal6, while for the lower levels use Metal1 to Metal2.\nTo connect different pins, use the LAYER.drawing layer. Conductors can either be the GatPoly or the Metal layers. Keep in mind that GatPoly.drawing has a higher resistance that Metal.drawing. To switch between the metal layers, use the device called “via_stack” and configure it accordingly.\nTo connect the gate of a MOS device the GatPoly needs to be connected to Metal1 through the Cnt layer. In contrast to the source and drain contacts this need to be done by hand. See figure 5 for a DRC clean connection of the gate of an NMOS device.\n\n\n\nExample DRC clean connection of the gate\n\n\nIn general, connect each device separately from each other. It might be tempting to design the layout close together, with overlapping NWells, Active and GatPoly areas, but this will lead to both DRC and LVS errors, which will be difficult to address as each device is close together. This is especially true, when first learning the process.\nThe layout of the 5T-OTA was done in multiple iterations, each iteration taught valuable lessons. The next section presents these lessons, outlining a specific workflow and offering tips and guidance for beginners.\n\n5.3.0.1 Tips and tricks for the Layout Process.\n\nRun LVS and DRC every 1 to 3 devices!\nAligning structures is easier when using a crosshair.\nEnable this by checking View-&gt;Crosshair Cursor\nUse the path tool whenever possible.\n\nThe tool has an adjustable width, which can be set on the bottom right menu.\nSet this width to 0.16 um to route DRC free on most layers.\nDo not use free form, as jagged shaped will create DRC errors.\n\nUse the shift key to snap to constrain vertically or horizontally.\nTo change the layer of structure, select the desired layer, select the structure and press shift+L\nCopying and pasting a structure will result in duplicating the structure in place. Use the move tool to separate both structures.\nIf things get too cluttered use the layer menu to declutter the interface.\n\nRight clicking and selecting “Visibility follows selection” will only show the selected layer.\nSetting different tabs for routing, DRC checking or overviewing the general layout is a good option to keep things tidy and readable\nChanging the appearance of different layers is a good idea, especially for layers that overlap, like pSD or NWell.\n\nUse the polygon only on special occasions as it is harder to clear of DRC errors.\n\nRemarks for those who come from EDA software like KiCad. These might change in future releases.\n\nThe devices will not be placed automatically.\nThere is no way of changing the grid, as it is defined in technology.\nThere is no “Ratsnest” or “Airal Connections”.\nThere is no DRC in the background, short circuits will only be caught by running the LVS.\nThere is no net highlighting.\nThere are no zones, but their absence will cause DRC errors.\nThere is no dragging, moving a device always means moving the “traces” by hand with it.\nThere are no footprints, the PCells are the fundamental footprints defined by the technology.\nText size can’t be set but will adjust to the zoom level.\nThe GUI is sometimes not working, especially true for LVS.\n\n\n\n5.3.1 Working with LVS during layouting\nThe Netlist Database Browser will provide an overview of all the nets both in the layout and the schematic or “Reference”. Each net has a number in brackets behind it. This number describes all the pins it is connected to. The netlists will only then match if these numbers are matched.\nDuring the layout process it is paramount to use the LAYER.text layers and the text tool to assign labels to the GatPoly or Metal1 layers. To select these layers, one may need to show all layers under Layer-&gt;Show all. To keep the comparison in the netlist browser simple, name the nets of the layout according to the names of the nets in the schematic. Please refer to the designer’s etiquette, while labeling the layout or schematic (see LINK).\nWhen working out the LVS it is advised to check mainly the devices in the list. This will provide a comprehensive overview of the devices, and the nets connected to them. Running LVS and DRC frequently will help with the overview.\nIt is normal that even the correctly wired devices are shown as errors. Especially the drain and source pins often swap places, which can’t be fixed by rotating the device. To clear the errors all nets connected to the device need to be cleared first. Only when all nets are correctly connected, will the device be clear of errors.\nHaving two nets on the same pit is always short circuit and should be handled with the highest priory.\nAfter a few MOS devices are placed, LVS will throw an error as their body “pin” is not connected to a defined potential. In an prior chapter the process of tying down the substrate was already explained. In this technology the substrate is a p-substrate, this means the NWells need to be tied down and there must be multiple tying down points for the p-substrate (see Figure 7). Please note that the size of the masks shown has been altered for visibility reasons. Also note that each PMOS needs its own tie to the VDD potential, while the ties for the NMOS can be placed anywhere on the layout, as the substrate is the bulk.\n\n\n\nTying down different types of bulks contacts. Not to scale.\n\n\nWhile using the netlist browser allows also for a rudimentary net highlighting in the layout. The practicality depends on the number of devices connected to the net. In general troubleshooting get more difficult, the more pins are connected to the same net.\n\n\n5.3.2 Working with DRC during layouting.\nRunning the DRC often and addressing them as soon as possible, allows for a denser and generally more compact layout. It also reduces the time spend reworking the layout after all devices have been connected.\nAs described in chapter (link to chapter) the “Marker Database Browser” is a built-in tool for addressing DRC errors. This tool shows the amount of DRC errors as well as the type. After following the steps described in the setup, one can open the Brower under Tool-&gt;Marker Browser. And running the DRC by selecting the run button.\nThe DRC will categorise in cells. Opening the DRC error log up will show the name of the error. Names link to the “SG13G2_os_layout_rules.pdf” by IHP. While KLayout also provides a description of the errors, it is best to use the DRC in conjunction with the DRC-PDF. The DRC-PDF provides context and dimensions for each error.\nWorking dually with the DRC-PDF and the DRC-Browser, allows the user to first clarify the DRC errors and than locate it by selecting it in the browser.\nA very useful tool to clear DRC errors is the “partial” tool in the toolbar. This allows to modify structures after they are placed. This speed up the workflow immensely as the structures don’t need to redrawn.\nSome DRC errors can’t be fixed at a given point of the design process. These DRC errors are usually due to density errors. But as the layout is not fully completed, cleaning these DRC errors has at best no impact on the design. Nevertheless, these errors must be cleared before the tape out.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Preamble to the Schematic</span>"
    ]
  },
  {
    "objectID": "content/_sec_finns_part.html#the-layout-of-the-5t-ota",
    "href": "content/_sec_finns_part.html#the-layout-of-the-5t-ota",
    "title": "4  Preamble to the Schematic",
    "section": "5.4 The layout of the 5T-OTA",
    "text": "5.4 The layout of the 5T-OTA\nTo design the 5T-OTA the schematic and the values of Professor Pretel were used (see).\nAs the export functionality of KLayout is rather limited, it is best to open the .gds file in KLayout directly, but the is also a SVG in the layout folder.\nWhile not very space efficient the layout followed the location of the MOSFETS in the schematic to ensure readability. This helped during the layout process, as it gave a clear structure to the layout. This also benefitted the understanding of the LVS and DRC during the layout immensely.\nAs space is one of main drivers of cost in IC design, a final version should be more mindful of the space used by the devices and traces. This would also clear the density errors, due to a higher density, because of the more compact design.\nThe design features multiple NWell and PWell Ties, to ensure that both bulks and NWell are connected to their potentials. Each PMOS-device has and NWell tie, which is closely located to the device. The PWell ties surround the design, as described in the introductory chapter to the integrated layout, the bulk shares one potential, but it is good practice to not use a star formation, to ensure this potential is evenly distributed.\nOne of the design goals of the design is the connection only on the first metal layer, this should ensure that the connection layers above are not influenced by the design. In addition, it provides a clear connection point for the top-level schematic.\nThe 5T-OTA.gds could easily be imported as cell into an arbitrary top- or mid-level design. Which concludes the design goal of this report.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Preamble to the Schematic</span>"
    ]
  },
  {
    "objectID": "content/_sec_filter-design.html",
    "href": "content/_sec_filter-design.html",
    "title": "5  Filter Design",
    "section": "",
    "text": "hello\nTEST GIT\nbe free finn!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Filter Design</span>"
    ]
  },
  {
    "objectID": "content/_sec_discussion.html",
    "href": "content/_sec_discussion.html",
    "title": "6  Discussion",
    "section": "",
    "text": "6.1 Stability Analysis\nthe critical thinkting place",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Discussion</span>"
    ]
  },
  {
    "objectID": "content/_sec_discussion.html#comparison",
    "href": "content/_sec_discussion.html#comparison",
    "title": "6  Discussion",
    "section": "6.2 Comparison",
    "text": "6.2 Comparison\nlike between python, ideal, real, etc",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Discussion</span>"
    ]
  },
  {
    "objectID": "content/_sec_discussion.html#is-filter-good",
    "href": "content/_sec_discussion.html#is-filter-good",
    "title": "6  Discussion",
    "section": "6.3 is filter good?",
    "text": "6.3 is filter good?\nreview and evaluate",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Discussion</span>"
    ]
  },
  {
    "objectID": "content/_sec_conclusion-outlook.html",
    "href": "content/_sec_conclusion-outlook.html",
    "title": "7  Conclusion",
    "section": "",
    "text": "7.1 Outlook\nbla bla reflection\nwhat else could be done ’n stuff",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Conclusion</span>"
    ]
  },
  {
    "objectID": "content/references.html",
    "href": "content/references.html",
    "title": "Bibliography",
    "section": "",
    "text": "Fliege, Norbert. 1991. Systhemtheorie. 1st ed. Stuttgart:\nTeubner.\n\n\nH. Pretl and Michael Koefinger. 2025. “Analog Circuit\nDesign.” https://iic-jku.github.io/analog-circuit-design/.\n\n\nPretl, Harald, and Georg Zachl. 2025. “GitHub Repository of the\nIIC-OSIC-TOOLS.” Zenodo. https://doi.org/10.5281/zenodo.14634518.\n\n\nRao, K. R. K., and C. P. Ravikumar. 2012. Analog System Lab Kit PRO\nMANUAL. Texas Instruments.\n\n\nRazavi, Behzad. 2018. “The Biquadratic Filter.” IEEE\nSolid-State Circuit Magazine, 11–16.\n\n\n———. 2024. “The Design of a Biquadratic Filter.” IEEE\nSolid-State Circuit Magazine, 6–13.\n\n\nReisch, Michael. 2007. Elektronische Bauelemente - Funktion,\nGrundschaltungen, Modellierung Mit SPICE. 2nd ed. Stuttgart:\nSpringer-Verlag.\n\n\nRenner, Nils. 2025. “Biquadratic IIR (SOS) Filters.”\n\n\nSchmid, H. 2000. “Approximating the Universal Active\nElement.” IEEE Transactions on Circuits and Systems II:\nAnalog and Digital Signal Processing 47 (11): 1160–69. https://doi.org/10.1109/82.885124.",
    "crumbs": [
      "Bibliography"
    ]
  }
]